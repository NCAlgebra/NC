(*************************************************************************
 *         This file was automatically generated by md2usage.py          *
 *                   on 2022-02-11 16:38:01.854221                       *
 *************************************************************************)


(* aj *)
aj::usage = "\
aj[expr] is the adjoint of expression expr. It is a conjugate linear involution.

See also: tp, co.";

(* co *)
co::usage = "\
co[expr] is the conjugate of expression expr. It is a linear involution.

See also: aj.";

(* Id *)
Id::usage = "\
Id is noncommutative multiplicative identity. Actually Id is now set equal 1.";

(* inv *)
inv::usage = "\
inv[expr] is the 2-sided inverse of expression expr.

If Options[inv, Distrubute] is False (the default) then

    inv[a**b]

returns inv[a**a]. Conversely, if Options[inv, Distrubute] is True then it returns inv[b]**inv[a].";

(* rt *)
rt::usage = "\
rt[expr] is the root of expression expr.";

(* tp *)
tp::usage = "\
tp[expr] is the tranpose of expression expr. It is a linear involution.

See also: aj, co.";

(* CommutativeQ *)
CommutativeQ::usage = "\
CommutativeQ[expr] is True if expression expr is commutative (the default), and False if expr is noncommutative.

See also: SetCommutative, SetNonCommutative.";

(* NonCommutativeQ *)
NonCommutativeQ::usage = "\
NonCommutativeQ[expr] is equal to Not[CommutativeQ[expr]].

See also: CommutativeQ.";

(* SetCommutative *)
SetCommutative::usage = "\
SetCommutative[a,b,c,...] sets all the Symbols a, b, c, … to be commutative.

See also: SetNonCommutative, CommutativeQ, NonCommutativeQ.";

(* SetCommutativeHold *)
SetCommutativeHold::usage = "\
SetCommutativeHold[a,b,c,...] sets all the Symbols a, b, c, … to be commutative.

SetCommutativeHold has attribute HoldAll and can be used to set Symbols which have already been assigned a value.

See also: SetNonCommutativeHold, SetCommutative, SetNonCommutative, CommutativeQ, NonCommutativeQ.";

(* SetNonCommutative *)
SetNonCommutative::usage = "\
SetNonCommutative[a,b,c,...] sets all the Symbols a, b, c, … to be noncommutative.

See also: SetCommutative, CommutativeQ, NonCommutativeQ.";

(* SetNonCommutativeHold *)
SetNonCommutativeHold::usage = "\
SetNonCommutativeHold[a,b,c,...] sets all the Symbols a, b, c, … to be noncommutative.

SetNonCommutativeHold has attribute HoldAll and can be used to set Symbols which have already been assigned a value.

See also: SetCommutativeHold, SetCommutative, CommutativeQ, NonCommutativeQ.";

(* SetCommutativeFunction *)
SetCommutativeFunction::usage = "\
SetCommutativeFunction[f] sets expressions with Head f, i.e. functions, to be commutative.

By default, expressions in which the Head or any of its arguments is noncommutative will be considered noncommutative. For example,

    SetCommutative[tr];
    a ** b ** tr[a ** b]

evaluates to a ** b ** tr[a ** b] while

    SetCommutativeFunction[tr];
    a ** b ** tr[a ** b]

evaluates to tr[a**b] * a ** b.

See also: SetCommutative, SetNonCommutative, CommutativeQ, NonCommutativeQ.";

(* SNC *)
SNC::usage = "\
SNC is an alias for SetNonCommutative.

See also: SetNonCommutative.";

(* SetCommutingOperators *)
SetCommutingOperators::usage = "\
SetCommutingOperators[a,b] will define a rule that substitute any noncommutative product b ** a by a ** b, effectively making the pair a and b commutative. If you want to create a rule to replace a ** b by b ** a use SetCommutingOperators[b,a] instead.

See also: UnsetCommutingOperators, CommutingOperatorsQ";

(* UnsetCommutingOperators *)
UnsetCommutingOperators::usage = "\
UnsetCommutingOperators[a,b] remove any rules previously created by SetCommutingOperators[a,b] or SetCommutingOperators[b,a].

See also: SetCommutingOperators, CommutingOperatorsQ";

(* CommutingOperatorsQ *)
CommutingOperatorsQ::usage = "\
CommutingOperatorsQ[a,b] returns True if a and b are commuting operators.

See also: SetCommutingOperators, UnsetCommutingOperators";

(* Commutative *)
Commutative::usage = "\
Commutative[symbol] is commutative even if symbol is noncommutative.

See also: CommuteEverything, CommutativeQ, SetCommutative, SetNonCommutative.";

(* CommuteEverything *)
CommuteEverything::usage = "\
CommuteEverything[expr] is an alias for BeginCommuteEverything.

See also: BeginCommuteEverything, Commutative.";

(* BeginCommuteEverything *)
BeginCommuteEverything::usage = "\
BeginCommuteEverything[expr] sets all symbols appearing in expr as commutative so that the resulting expression contains only commutative products or inverses. It issues messages warning about which symbols have been affected.

EndCommuteEverything[] restores the symbols noncommutative behaviour.

BeginCommuteEverything answers the question what does it sound like?

See also: EndCommuteEverything, Commutative.";

(* EndCommuteEverything *)
EndCommuteEverything::usage = "\
EndCommuteEverything[expr] restores noncommutative behaviour to symbols affected by BeginCommuteEverything.

See also: BeginCommuteEverything, Commutative.";

(* ExpandNonCommutativeMultiply *)
ExpandNonCommutativeMultiply::usage = "\
ExpandNonCommutativeMultiply[expr] expands out **s in expr.

For example

    ExpandNonCommutativeMultiply[a**(b+c)]

returns

    a**b + a**c.

See also: NCExpand, NCE.";

(* NCExpand *)
NCExpand::usage = "\
NCExpand is an alias for ExpandNonCommutativeMultiply.

See also: ExpandNonCommutativeMultiply, NCE.";

(* NCE *)
NCE::usage = "\
NCE is an alias for ExpandNonCommutativeMultiply.

See also: ExpandNonCommutativeMultiply, NCExpand.";
