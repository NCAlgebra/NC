(*************************************************************************
 *         This file was automatically generated by md2usage.py          *
 *                   on 2023-02-20 10:32:40.677485                       *
 *************************************************************************)


(* aj *)
aj::usage = "\
aj[expr] is the adjoint of expression expr. It is a conjugate linear involution.

See also: tp, co.";

(* co *)
co::usage = "\
co[expr] is the conjugate of expression expr. It is a linear involution.

See also: aj.";

(* Id *)
Id::usage = "\
Id is noncommutative multiplicative identity. Actually Id is now set equal 1.";

(* inv *)
inv::usage = "\
inv[expr] is the 2-sided inverse of expression expr.

If Options[inv, Distrubute] is False (the default) then

    inv[a**b]

returns inv[a**a]. Conversely, if Options[inv, Distrubute] is True then it returns inv[b]**inv[a].";

(* rt *)
rt::usage = "\
rt[expr] is the root of expression expr.";

(* tp *)
tp::usage = "\
tp[expr] is the tranpose of expression expr. It is a linear involution.

See also: aj, co.";

(* CommutativeQ *)
CommutativeQ::usage = "\
CommutativeQ[expr] is True if expression expr is commutative (the default), and False if expr is noncommutative.

See also: SetCommutative, SetNonCommutative.";

(* NonCommutativeQ *)
NonCommutativeQ::usage = "\
NonCommutativeQ[expr] is equal to Not[CommutativeQ[expr]].

See also: CommutativeQ.";

(* SetCommutative *)
SetCommutative::usage = "\
SetCommutative[a,b,c,...] sets all the Symbols a, b, c, … to be commutative.

See also: SetNonCommutative, CommutativeQ, NonCommutativeQ.";

(* SetCommutativeHold *)
SetCommutativeHold::usage = "\
SetCommutativeHold[a,b,c,...] sets all the Symbols a, b, c, … to be commutative.

SetCommutativeHold has attribute HoldAll and can be used to set Symbols which have already been assigned a value.

See also: SetNonCommutativeHold, SetCommutative, SetNonCommutative, CommutativeQ, NonCommutativeQ.";

(* SetNonCommutative *)
SetNonCommutative::usage = "\
SetNonCommutative[a,b,c,...] sets all the Symbols a, b, c, … to be noncommutative.

See also: SetCommutative, CommutativeQ, NonCommutativeQ.";

(* SetNonCommutativeHold *)
SetNonCommutativeHold::usage = "\
SetNonCommutativeHold[a,b,c,...] sets all the Symbols a, b, c, … to be noncommutative.

SetNonCommutativeHold has attribute HoldAll and can be used to set Symbols which have already been assigned a value.

See also: SetCommutativeHold, SetCommutative, CommutativeQ, NonCommutativeQ.";

(* SetCommutativeFunction *)
SetCommutativeFunction::usage = "\
SetCommutativeFunction[f] sets expressions with Head f, i.e. functions, to be commutative.

By default, expressions in which the Head or any of its arguments is noncommutative will be considered noncommutative. For example,

    SetCommutative[trace];
    a ** b ** trace[a ** b]

evaluates to a ** b ** trace[a ** b] while

    SetCommutativeFunction[trace];
    a ** b ** trace[a ** b]

evaluates to trace[a ** b] * a ** b.

See also: SetCommutative, SetNonCommutative, CommutativeQ, NonCommutativeQ, tr.";

(* SetNonCommutativeFunction *)
SetNonCommutativeFunction::usage = "\
SetNonCommutativeFunction[f] sets expressions with Head f, i.e. functions, to be non commutative. This is only necessary if it has been previously set commutative by SetCommutativeFunction.

See also: SetCommutativeFunction, SetCommutative, SetNonCommutative, CommutativeQ, NonCommutativeQ, tr.";

(* SNC *)
SNC::usage = "\
SNC is an alias for SetNonCommutative.

See also: SetNonCommutative.";

(* SetCommutingOperators *)
SetCommutingOperators::usage = "\
SetCommutingOperators[a,b] will define a rule that substitute any noncommutative product b ** a by a ** b, effectively making the pair a and b commutative. If you want to create a rule to replace a ** b by b ** a use SetCommutingOperators[b,a] instead.

See also: UnsetCommutingOperators, CommutingOperatorsQ";

(* UnsetCommutingOperators *)
UnsetCommutingOperators::usage = "\
UnsetCommutingOperators[a,b] remove any rules previously created by SetCommutingOperators[a,b] or SetCommutingOperators[b,a].

See also: SetCommutingOperators, CommutingOperatorsQ";

(* CommutingOperatorsQ *)
CommutingOperatorsQ::usage = "\
CommutingOperatorsQ[a,b] returns True if a and b are commuting operators.

See also: SetCommutingOperators, UnsetCommutingOperators";

(* NCNonCommutativeSymbolOrSubscriptQ *)
NCNonCommutativeSymbolOrSubscriptQ::usage = "\
NCNonCommutativeSymbolOrSubscriptQ[expr] returns True if expr is an noncommutative symbol or a noncommutative symbol subscript.

See also: NCSymbolOrSubscriptQ, NCPowerQ.";

(* NCPowerQ *)
NCPowerQ::usage = "\
NCPowerQ[expr] returns True if expr is an noncommutative symbol or symbol subscript or a positive power of a noncommutative symbol or symbol subscript.

See also: NCNonCommutativeSymbolOrSubscriptQ, NCSymbolOrSubscriptQ.";

(* Commutative *)
Commutative::usage = "\
Commutative[symbol] is commutative even if symbol is noncommutative.

See also: CommuteEverything, CommutativeQ, SetCommutative, SetNonCommutative.";

(* CommuteEverything *)
CommuteEverything::usage = "\
CommuteEverything[expr] is an alias for BeginCommuteEverything.

See also: BeginCommuteEverything, Commutative.";

(* BeginCommuteEverything *)
BeginCommuteEverything::usage = "\
BeginCommuteEverything[expr] sets all symbols appearing in expr as commutative so that the resulting expression contains only commutative products or inverses. It issues messages warning about which symbols have been affected.

EndCommuteEverything[] restores the symbols noncommutative behaviour.

BeginCommuteEverything answers the question what does it sound like?

See also: EndCommuteEverything, Commutative.";

(* EndCommuteEverything *)
EndCommuteEverything::usage = "\
EndCommuteEverything[expr] restores noncommutative behaviour to symbols affected by BeginCommuteEverything.

See also: BeginCommuteEverything, Commutative.";

(* ExpandNonCommutativeMultiply *)
ExpandNonCommutativeMultiply::usage = "\
ExpandNonCommutativeMultiply[expr] expands out **s in expr.

For example

    ExpandNonCommutativeMultiply[a**(b+c)]

returns

    a**b + a**c.

See also: NCExpand, NCE.";

(* NCExpand *)
NCExpand::usage = "\
NCExpand is an alias for ExpandNonCommutativeMultiply.

See also: ExpandNonCommutativeMultiply, NCE.";

(* NCE *)
NCE::usage = "\
NCE is an alias for ExpandNonCommutativeMultiply.

See also: ExpandNonCommutativeMultiply, NCExpand.";

(* NCExpandExponents *)
NCExpandExponents::usage = "\
NCExpandExponents[expr] expands out powers of the monomials appearing in expr.

For example

    NCExpandExponents[a**(b**c)^2**(c+d)]

returns

    a**b**c**b**c**(c+d).

NCExpandExponents only expands powers of monomials. Powers of symbols or other expressions are not expanded using NCExpandExponents.

See also: NCToList ExpandNonCommutativeMultiply, NCExpand, NCE.";

(* NCToList *)
NCToList::usage = "\
NCToList[expr] produces a list with the symbols appearing in monomial expr. If expr is not a monomial it remains unevaluated. Powers of symbols are expanded before the list is produced.

For example

    NCToList[a**b**a^2]

returns

    {a,b,a,a}

See also: NCExpandExponents, ExpandNonCommutativeMultiply, NCExpand, NCE.";
