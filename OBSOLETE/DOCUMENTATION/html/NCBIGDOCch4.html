<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title>4 NC Commands</title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/mn.html)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/mn.html)"> 
<!-- html,index=2,2 --> 
<meta name="src" content="NCBIGDOC.tex"> 
<meta name="date" content="2010-01-06 13:44:00"> 
<link rel="stylesheet" type="text/css" href="NCBIGDOC.css"> 
</head><body 
>
   <!--l. 1--><div class="crosslinks"><p class="noindent">[<a 
href="NCBIGDOCch5.html" >next</a>] [<a 
href="NCBIGDOCch3.html" >prev</a>] [<a 
href="NCBIGDOCch3.html#tailNCBIGDOCch3.html" >prev-tail</a>] [<a 
href="#tailNCBIGDOCch4.html">tail</a>] [<a 
href="NCBIGDOCpa1.html#NCBIGDOCch4.html" >up</a>] </p></div>
   <h2 class="chapterHead"><span class="titlemark">Chapter&#x00A0;4</span><br><a 
 id="x8-230004"></a>NC Commands</h2>
<!--l. 4--><p class="noindent">Mathematica 3.0 has a lovely graphical user interface which uses Palettes. Mathematica Palettes
display the most important commands and prompt the user. We have such a Palette for
NCAlgebra and NCGB which contain most of the commands in this chapter. See the TEAR OFF
Section in the back for a picture of the Mma Palettes for NCAlgebra and NCGB. To pop up this
Palette, open a notebook, load NCAlgebra or NCGB, then open the file NCPalette.nb. If
you are in a directory containing the file NCPalette.nb you can open it directly from a
notebook.
   <h3 class="sectionHead"><span class="titlemark">4.1   </span> <a 
 id="x8-240004.1"></a>Manipulating an expression</h3>
<!--l. 26--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.1.1   </span> <a 
 id="x8-250004.1.1"></a>ExpandNonCommutativeMultiply[expr]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">NCE,NCExpand</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description:
      <span 
class="cmmi-12">ExpandNonCommutativeMultiply</span>[<span 
class="cmmi-12">expr</span>] expands out NonCommutativeMultiply&#8217;s in
      <span 
class="cmmi-12">expr</span>. It is the noncommutative generalization of the Mma Expand command.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments:  <span 
class="cmmi-12">expr </span>is an algebraic expression.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: None </dd></dl>

<a 
 id="dx8-25001"></a>
<a 
 id="dx8-25002"></a>
<!--l. 47--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.1.2   </span> <a 
 id="x8-260004.1.2"></a>NCCollect[expr, aListOfVariables]</h4>

      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">NCC</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description:   <span 
class="cmmi-12">NCCollect</span>[<span 
class="cmmi-12">expr,aListOfV ariables</span>]   collects   terms   of   expression   <span 
class="cmmi-12">expr</span>
      according to the elements of <span 
class="cmmi-12">aListOfV ariables </span>and attempts to combine them using a
      particular list of rules called <span 
class="cmmi-12">rulesCollect</span>. NCCollect is weaker than NCStrongCollect
      in that first-order and second-order terms are not collected together. NCCollect uses
      NCDecompose, and then NCStrongCollect, and then NCCompose.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments:  <span 
class="cmmi-12">expr </span>is an algebraic expression. <span 
class="cmmi-12">aListOfV ariables </span>is a list of variables.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: While <span 
class="cmmi-12">NCCollect</span>[<span 
class="cmmi-12">expr,x</span>] always returns mathematically correct
      expressions, it may not collect <span 
class="cmmi-12">x </span>from as many terms as it should. If <span 
class="cmmi-12">expr </span>has been
      expanded in the previous step, the problem does not arise. If not, the pattern match
      behind NCCollect may not get entirely inside of every factor where <span 
class="cmmi-12">x </span>appears. </dd></dl>
<a 
 id="dx8-26001"></a>
<!--l. 64--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.1.3   </span> <a 
 id="x8-270004.1.3"></a>NCStrongCollect[expr, aListOfVariables]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">NCSC</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description:   It   collects   terms   of   expression   <span 
class="cmmi-12">expr  </span>according   to   the   elements   of
      <span 
class="cmmi-12">aListOfV ariables </span>and attempts to combine them using the particular list of rules
      called rulesCollect. In the noncommutative case, the Taylor expansion, and hence the
      collect function, is not uniquely specified. This collect function often collects too much
      and while mathematically correct is often stronger than you want. For example, <span 
class="cmmi-12">x </span>will
      factor out of terms where it appears both linearly a quadratically thus mixing orders.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">expr </span>is an algebraic expression. <span 
class="cmmi-12">aListOfV ariables </span>is a list of variables.

      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: Not well documented. </dd></dl>
<a 
 id="dx8-27001"></a>
<!--l. 71--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.1.4   </span> <a 
 id="x8-280004.1.4"></a>NCCollectSymmetric[expr]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">NCCSym</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: None
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">expr </span>is an algebraic expression.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: None </dd></dl>
<a 
 id="dx8-28001"></a>
<!--l. 90--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.1.5   </span> <a 
 id="x8-290004.1.5"></a>NCTermsOfDegree[expr,aListOfVariables,indices]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: <span 
class="cmmi-12">NCTermsOfDegree</span>[<span 
class="cmmi-12">expr,aListOfV ariables,indices</span>] returns an expression
      such that each term is homogeneous of degree given by the <span 
class="cmmi-12">indices </span>in the variables of
      <span 
class="cmmi-12">aListOfV ariables</span>. For example, <span 
class="cmmi-12">NCTermsOfDegree</span>[<span 
class="cmmi-12">x</span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">y</span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x</span>+<span 
class="cmmi-12">x</span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x</span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">y</span>+<span 
class="cmmi-12">x</span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x</span>+
      <span 
class="cmmi-12">x</span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">w,</span><span 
class="cmsy-10x-x-120">{</span><span 
class="cmmi-12">x,y</span><span 
class="cmsy-10x-x-120">}</span><span 
class="cmmi-12">,indices</span>] returns <span 
class="cmmi-12">x</span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x</span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">y </span>+<span 
class="cmmi-12">x</span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">y </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x </span>if <span 
class="cmmi-12">indices </span>= <span 
class="cmsy-10x-x-120">{</span>2<span 
class="cmmi-12">, </span>1<span 
class="cmsy-10x-x-120">}</span>, return <span 
class="cmmi-12">x</span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">w</span>
      if <span 
class="cmmi-12">indices </span>= <span 
class="cmsy-10x-x-120">{</span>1<span 
class="cmmi-12">, </span>0<span 
class="cmsy-10x-x-120">}</span>, return <span 
class="cmmi-12">x </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x </span>if <span 
class="cmmi-12">indices </span>= <span 
class="cmsy-10x-x-120">{</span>2<span 
class="cmmi-12">, </span>0<span 
class="cmsy-10x-x-120">} </span>and returns 0 otherwise. This is
      like Mathematica&#8217;s Coefficient command, but for the noncommuting case. However, it
      actually gives the terms and not the coefficients of the terms.

      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">expr </span>is an algebraic expression, <span 
class="cmmi-12">aListOfV ariables </span>is a list of variables and
      indices is a list of positive integers which is the same length as <span 
class="cmmi-12">aList</span>.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: Not available before NCAlgebra 1.0 </dd></dl>
<a 
 id="dx8-29001"></a>
<!--l. 103--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.1.6   </span> <a 
 id="x8-300004.1.6"></a>NCSolve[expr1==expr2,var]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: <span 
class="cmmi-12">NCSolve</span>[<span 
class="cmmi-12">expr</span>1 == <span 
class="cmmi-12">expr</span>2<span 
class="cmmi-12">,var</span>] solves some simple equations which are linear
      in the unknown <span 
class="cmmi-12">var</span>. Note that in the noncommutative case, many equations such as
      Lyapunov equations cannot be solved for an unknown. This obviously is a limitation
      on the NCSolve command.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">expr</span>1 and <span 
class="cmmi-12">expr</span>2 are Mathematica expressions. <span 
class="cmmi-12">var </span>is a single variable.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: See description. </dd></dl>
<a 
 id="dx8-30001"></a>
<!--l. 125--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.1.7   </span> <a 
 id="x8-310004.1.7"></a>Substitute[expr,aListOfRules,(Optional On)]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">Sub</span>

      </dd><dt class="description">
 </dt><dd 
class="description">Description:  It  repeatedly  replaces  one  symbol  or  sub-expression  in  the  expression  by
      another expression as specified by the rule. (See Wolfram&#8217;s Mathematica 2.* book page
      54.) More recently, we wrote the Transform command (<span 
class="cmsy-10x-x-120">&#167;</span><a 
href="#x8-350004.1.11">4.1.11<!--tex4ht:ref: command:Transform --></a>) which apprears to be
      better.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">expr </span>is an algebraic expression. <span 
class="cmmi-12">aListOfRules </span>is a single rule or list of rules
      specifying the substitution to be made. On = save rules to Rules.temp, temporarily
      over-riding SaveRules[Off]. &#8216;Off&#8217; cannot over-ride SaveRules[On].
      </dd><dt class="description">
 </dt><dd 
class="description">Comments  /  Limitations:   The  symbols  /.  and  //.  are  often  used  in  Mathematica  as
      methods for substituting one expression for another. This method of substitution often
      does  not  work  when  the  expression  to  be  substituted  is  a  subexpression  within  a
      (noncommutative) product. This Substitute command is the noncommutative analogue
      to //. </dd></dl>
<a 
 id="dx8-31001"></a>
<!--l. 151--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.1.8   </span> <a 
 id="x8-320004.1.8"></a>SubstituteSymmetric[expr, aListOfRules, (optional On)]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">SubSym</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: When a rule specifies that <span 
class="cmmi-12">a </span><span 
class="cmsy-10x-x-120">&#x2192; </span><span 
class="cmmi-12">b</span>, then SubSym also makes the replacement
      <span 
class="cmmi-12">tp</span>[<span 
class="cmmi-12">a</span>] <span 
class="cmsy-10x-x-120">&#x2192; </span><span 
class="cmmi-12">tp</span>[<span 
class="cmmi-12">b</span>]<span 
class="cmmi-12">.</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">expr </span>is an algebraic expression. <span 
class="cmmi-12">aListOfRules </span>is a single rule or list of rules
      specifying the substitution to be made. On = save rules to Rules.temp, temporarily
      over-rides SaveRules[Off]. &#8217;Off&#8217; can not over-ride SaveRules[On].
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: None </dd></dl>

<a 
 id="dx8-32001"></a>
<!--l. 183--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.1.9   </span> <a 
 id="x8-330004.1.9"></a>SubstituteSingleReplace[expr, aListOfRules, (optional On)]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">SubSingleRep</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: Replaces one symbol or sub-expression in the expression by another expression
      as specified by the rule. (See Wolfram&#8217;s Mathematica 2.* page 54.)
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments:  <span 
class="cmmi-12">expr </span>is an algebraic expression. <span 
class="cmmi-12">aListOfRules </span>is a single rule or list of rules
      specifying the substitution to be made. On = save rules to Rules.temp, temporarily
      over-rides SaveRules[Off]. &#8216;Off&#8217; can not over-ride SaveRules[On].
      </dd><dt class="description">
 </dt><dd 
class="description">Comments  /  Limitations:  The  symbols  /.  and  //.  are  often  used  in  Mathematica  as
      methods for substituting one expression for another. This method of substitution often
      does  not  work  when  the  expression  to  be  substituted  is  a  subexpression  within  a
      (noncommutative) product. This Substitute command is the noncommutative analogue
      to /. </dd></dl>
<a 
 id="dx8-33001"></a>
<!--l. 196--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.1.10   </span> <a 
 id="x8-340004.1.10"></a>SubstituteAll[expr, aListOfRules, (optional On)]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">SubAll</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: For every rule <span 
class="cmmi-12">a </span><span 
class="cmsy-10x-x-120">&#x2192; </span><span 
class="cmmi-12">b</span>, SubAll also replaces,

      <center class="math-display" >
      <img 
src="NCBIGDOC8x.png" alt="tp[a] &#x2192; tp[b]  inv[a] &#x2192;  inv[b]   rt[a] &#x2192; rt[b].
      " class="math-display" ></center>
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments:  <span 
class="cmmi-12">expr </span>is an algebraic expression. <span 
class="cmmi-12">aListOfRules </span>is a single rule or list of rules
      specifying the substitution to be made. On = save rules to Rules.temp, temporarily
      over-riding SaveRules[Off]. &#8217;Off&#8217; can not over-ride SaveRules[On].
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: None </dd></dl>
<a 
 id="dx8-34001"></a>
<!--l. 207--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.1.11   </span> <a 
 id="x8-350004.1.11"></a>Transform[expr,aListOfRules]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">Transform</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: None
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: Transform is essentially a more efficient version of Substitute. It has the same
      functionality as Substitute.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: <span 
class="cmmi-12">expr </span>is an algebraic expression. <span 
class="cmmi-12">aListOfRules </span>is a single rule or
      list of rules specifying the substitution to be made.  </dd></dl>
<a 
 id="dx8-35001"></a>
<!--l. 208--><p class="noindent">Beware: Transform only applies rules once rather than repeatedly.

<!--l. 227--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.1.12   </span> <a 
 id="x8-360004.1.12"></a>GrabIndeterminants[ aListOfPolynomialsOrRules]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">none</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description:    <span 
class="cmtt-12">GrabIndeterminants[L] </span>returns  the  indeterminates  found  in  the  list
      of  (noncommutative)  expressions  or  rules  <span 
class="cmmi-12">L</span>.  For  example,  <span 
class="cmtt-12">GrabIndeterminants[</span>
      <span 
class="cmsy-10x-x-120">{ </span><span 
class="cmtt-12">x**Inv[x]**x + Tp[Inv[x+a]],</span> <span 
class="cmtt-12">3 + 4 Inv[a]**b**Inv[a] + x </span><span 
class="cmsy-10x-x-120">}</span><span 
class="cmtt-12">]</span> returns
      <center class="math-display" >
      <img 
src="NCBIGDOC9x.png" alt="{ x,  Inv[x],  Tp[Inv[x+a]],    Inv[a],  b  }.
      " class="math-display" ></center>
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: aListOfPolynomialsOrRules is a list of (noncommutative) expressions or rules.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations:   </dd></dl>
<a 
 id="dx8-36001"></a>
<!--l. 247--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.1.13   </span> <a 
 id="x8-370004.1.13"></a>GrabVariables[ aListOfPolynomialsOrRules ]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">none</span>

      </dd><dt class="description">
 </dt><dd 
class="description">Description: <span 
class="cmtt-12">GrabVariables[ aListOfPolynomialsOrRules ] </span>returns the variables found
      in the list of (noncommutative) expressions or rules aListOfPolynomialsOrRules. It is
      similar to the Mathematica command <span 
class="cmtt-12">Variables[] </span>which takes as an argument a list
      of polynomials in commutative variables or functions of variables. For example,
      <center class="math-display" >
      <img 
src="NCBIGDOC10x.png" alt="GrabVariables[   {  x**Inv[x]**x   + Tp[Inv[x+a]],    3 + 4  Inv[a]**b**Inv[a]    + x  }]
      " class="math-display" ></center> returns
      <center class="math-display" >
      <img 
src="NCBIGDOC11x.png" alt="{ x,  a, b  }.
      " class="math-display" ></center>
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: aListOfPolynomialsOrRules is a list of (noncommutative) expressions or rules.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations:   </dd></dl>
<a 
 id="dx8-37001"></a>

<!--l. 256--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.1.14   </span> <a 
 id="x8-380004.1.14"></a>NCBackward[expr]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">NCB</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: It applies the rules
      <center class="math-display" >
      <img 
src="NCBIGDOC12x.png" alt="inv[Id - B * *A] * *B &#x2192;  B * *inv[Id - A * *B]
      " class="math-display" ></center>
      <center class="math-display" >
      <img 
src="NCBIGDOC13x.png" alt="inv[Id -  B * *A] * *inv[A] &#x2192; inv[A] * *inv[Id - A * *B]
      " class="math-display" ></center>
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">expr </span>is an algebraic expression.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: None </dd></dl>
<a 
 id="dx8-38001"></a>

<!--l. 265--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.1.15   </span> <a 
 id="x8-390004.1.15"></a>NCForward[expr]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">NCF</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: It applies the rules
      <center class="math-display" >
      <img 
src="NCBIGDOC14x.png" alt="B * *inv[Id - A * *B] &#x2192;  inv[Id - B * *A] * *B
      " class="math-display" ></center>
      <center class="math-display" >
      <img 
src="NCBIGDOC15x.png" alt="inv[B] * *inv[Id - B * *A] &#x2192;  inv[Id - B * *A] * *inv[A]
      " class="math-display" ></center>
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">expr </span>is an algebraic expression.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: None </dd></dl>
<a 
 id="dx8-39001"></a>

<!--l. 289--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.1.16   </span> <a 
 id="x8-400004.1.16"></a>NCMonomial[expr]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description:  NCMonomail  changes  the  look  of  an  expression  by  replacing  <span 
class="cmmi-12">n</span>th  integer
      powers of the NonCommutative variable <span 
class="cmmi-12">x</span>, with the product of <span 
class="cmmi-12">n </span>copies of <span 
class="cmmi-12">x</span>. For
      example,  <span 
class="cmmi-12">NCMonomial</span>[2<span 
class="cmmi-12">x</span><span 
class="cmr-8">2</span>  + 5<span 
class="cmmi-12">x</span><span 
class="cmr-8">4</span>]  evaluates  to  2<span 
class="cmmi-12">x </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x </span>+ 5<span 
class="cmmi-12">x </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x </span>and
      <span 
class="cmmi-12">NCMonomial</span>[(<span 
class="cmmi-12">x</span><span 
class="cmr-8">2</span>) <span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">z </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x</span>] evaluates to <span 
class="cmmi-12">x </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">z </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x</span>.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: Any noncommutative expression.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: The program greatly eases the task of typing in polynomials. For
      example, instead of typing <span 
class="cmmi-12">x </span>= <span 
class="cmmi-12">x</span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x</span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x</span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x</span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x</span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x</span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x</span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x</span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x</span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x</span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x</span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x</span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">y</span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x</span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x</span>,
      one can type <span 
class="cmmi-12">x </span>= <span 
class="cmmi-12">NCMono</span>[(<span 
class="cmmi-12">x</span><span 
class="cmr-8">12</span>)<span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">y</span><span 
class="cmsy-10x-x-120">**</span>(<span 
class="cmmi-12">x</span><span 
class="cmr-8">2</span>)]. NCMono expands only integer exponents.
      This program will be (or has been, depending on the version of code which you have)
      superseded by NCMonomial and NCUnMonomial. NCMonomial implements the same
      functionality as NCMonomial and NCUnMonomial reverses the process. <span 
class="cmbx-12">Caution:</span>
      Mathematica treats <span 
class="cmmi-12">x</span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">y</span><span 
class="cmr-8">2</span> as (<span 
class="cmmi-12">x</span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">y</span>)<span 
class="cmr-8">2</span> and so to have Mathematica acknowledge <span 
class="cmmi-12">x</span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">y</span><span 
class="cmr-8">2</span>
      then input <span 
class="cmmi-12">x</span><span 
class="cmsy-10x-x-120">**</span>(<span 
class="cmmi-12">y</span><span 
class="cmr-8">2</span>) exactly. This has nothing to do with NCAlgebra or NCMonomial.
      </dd></dl>
<a 
 id="dx8-40001"></a>
<!--l. 306--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.1.17   </span> <a 
 id="x8-410004.1.17"></a>NCUnMonomial[expr]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: NCUnMonomial reverses what NCMonomial does. NCUnMonomial changes
      the  look  of  an  expression  by  replacing  a  product  of  <span 
class="cmmi-12">n </span>copies  of  <span 
class="cmmi-12">x </span>with  <span 
class="cmmi-12">x</span><sup ><span 
class="cmmi-8">n</span></sup>.  For

      example, <span 
class="cmmi-12">NCUnMonomial</span>[2<span 
class="cmmi-12">x </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x </span>+ 5<span 
class="cmmi-12">x </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x</span>] evaluates to 2<span 
class="cmmi-12">x</span><span 
class="cmr-8">2</span> + 5<span 
class="cmmi-12">x</span><span 
class="cmr-8">4</span>  and
      <span 
class="cmmi-12">NCUnMonomial</span>[<span 
class="cmmi-12">x </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">z </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x</span>] evaluates to (<span 
class="cmmi-12">x</span><span 
class="cmr-8">2</span>) <span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">z </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x</span>.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: Any noncommutative expression.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: See NCMonomial. NCAlgebra does not effectively manipulate
      expressions involving powers (such as (<span 
class="cmmi-12">x</span><span 
class="cmr-8">2</span>)) </dd></dl>
<a 
 id="dx8-41001"></a>
<!--l. 310--><p class="noindent">
   <h3 class="sectionHead"><span class="titlemark">4.2   </span> <a 
 id="x8-420004.2"></a>Simplification</h3>
<!--l. 312--><p class="noindent">This area is under developement so stronger commands will appear in later versions. What we
mean by simplify is not in the spirit of Mathematica&#8217;s Simplify. They tend to factor expressions so
that the expressions become very short. We expand expressions apply rules to the expressions
which incorporate special relations the entries satisfy. Then we rely on cancelation of terms. The
theoretical background lies in noncommutative Gröbner basis theory, and the rules we are
implementing come from papers of Helton, Stankus and Wavrik <span 
class="cmbx-12">[IEEE TAC March</span>
<span 
class="cmbx-12">1998]</span>.
<!--l. 320--><p class="indent">   The commands in this section are designed to simplify polynomials in <span 
class="cmmi-12">a</span>, <span 
class="cmmi-12">b</span>, <span 
class="cmmi-12">inv</span>[<span 
class="cmmi-12">S </span><span 
class="cmsy-10x-x-120">- </span><span 
class="cmmi-12">a </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">b</span>],
<span 
class="cmmi-12">inv</span>[<span 
class="cmmi-12">S </span><span 
class="cmsy-10x-x-120">- </span><span 
class="cmmi-12">b </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">a</span>], <span 
class="cmmi-12">inv</span>[<span 
class="cmmi-12">S </span><span 
class="cmsy-10x-x-120">- </span><span 
class="cmmi-12">a</span>], <span 
class="cmmi-12">inv</span>[<span 
class="cmmi-12">S </span><span 
class="cmsy-10x-x-120">- </span><span 
class="cmmi-12">b</span>] and a few slightly more complicated inverses.
<!--l. 324--><p class="indent">   The commands in order of strength are NCSR, NCS1R, NCS2R. Of course, for a
stronger the command, more rules get applied and so the command takes longer to
run.
<!--l. 329--><p class="indent">   First, NCS1R normalizes <span 
class="cmmi-12">inv</span>[<span 
class="cmmi-12">S </span><span 
class="cmsy-10x-x-120">- </span><span 
class="cmmi-12">a </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">b</span>] to <span 
class="cmmi-12">S</span><sup ><span 
class="cmsy-8">-</span><span 
class="cmr-8">1</span></sup> <span 
class="cmsy-10x-x-120">* </span><span 
class="cmmi-12">inv</span>[1 <span 
class="cmsy-10x-x-120">- </span>(<span 
class="cmmi-12">a </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">b</span>)<span 
class="cmmi-12">&#x2215;S</span>] provided <span 
class="cmmi-12">S </span>is a
commutative expression (only works for numbers <span 
class="cmmi-12">S </span>in version 0.2 of NCAlgebra). The following list
of rules are applied.
<!--l. 336--><p class="noindent">(0) <span 
class="cmmi-12">inv</span>[<span 
class="cmsy-10x-x-120">-</span>1 + <span 
class="cmmi-12">a</span>] <span 
class="cmsy-10x-x-120">&#x2192;-</span><span 
class="cmmi-12">inv</span>[1 <span 
class="cmsy-10x-x-120">- </span><span 
class="cmmi-12">a</span>]
<br class="newline">(1) <span 
class="cmmi-12">inv</span>[1 <span 
class="cmsy-10x-x-120">- </span><span 
class="cmmi-12">a</span>] (<span 
class="cmmi-12">a </span><span 
class="cmsy-10x-x-120">- </span><span 
class="cmmi-12">b</span>) <span 
class="cmmi-12">inv</span>[1 <span 
class="cmsy-10x-x-120">- </span><span 
class="cmmi-12">b</span>] <span 
class="cmsy-10x-x-120">&#x2192; </span><span 
class="cmmi-12">inv</span>[1 <span 
class="cmsy-10x-x-120">- </span><span 
class="cmmi-12">a</span>] <span 
class="cmsy-10x-x-120">- </span><span 
class="cmmi-12">inv</span>[1 <span 
class="cmsy-10x-x-120">- </span><span 
class="cmmi-12">b</span>]
<br class="newline">(2) <span 
class="cmmi-12">inv</span>[1 <span 
class="cmsy-10x-x-120">- </span><span 
class="cmmi-12">ab</span>] <span 
class="cmmi-12">inv</span>[<span 
class="cmmi-12">b</span>] <span 
class="cmsy-10x-x-120">&#x2192; </span><span 
class="cmmi-12">inv</span>[1 <span 
class="cmsy-10x-x-120">- </span><span 
class="cmmi-12">ba</span>] <span 
class="cmmi-12">a </span>+ <span 
class="cmmi-12">inv</span>[<span 
class="cmmi-12">b</span>]
<br class="newline">(3) <span 
class="cmmi-12">inv</span>[1 <span 
class="cmsy-10x-x-120">- </span><span 
class="cmmi-12">ab</span>] <span 
class="cmmi-12">ab </span><span 
class="cmsy-10x-x-120">&#x2192; </span><span 
class="cmmi-12">inv</span>[1 <span 
class="cmsy-10x-x-120">- </span><span 
class="cmmi-12">ab</span>] <span 
class="cmsy-10x-x-120">- </span>1
<br class="newline">(4) <span 
class="cmmi-12">abinv</span>[1 <span 
class="cmsy-10x-x-120">- </span><span 
class="cmmi-12">ab</span>] <span 
class="cmsy-10x-x-120">&#x2192; </span><span 
class="cmmi-12">inv</span>[1 <span 
class="cmsy-10x-x-120">- </span><span 
class="cmmi-12">ab</span>] <span 
class="cmsy-10x-x-120">- </span>1
<br class="newline">(5) <span 
class="cmmi-12">inv</span>[<span 
class="cmmi-12">c</span>] <span 
class="cmmi-12">inv</span>[1 <span 
class="cmsy-10x-x-120">- </span><span 
class="cmmi-12">cb</span>] <span 
class="cmsy-10x-x-120">&#x2192; </span><span 
class="cmmi-12">inv</span>[1 <span 
class="cmsy-10x-x-120">- </span><span 
class="cmmi-12">bc</span>] <span 
class="cmmi-12">inv</span>[<span 
class="cmmi-12">c</span>]
<br class="newline">(6) <span 
class="cmmi-12">b inv</span>[1 <span 
class="cmsy-10x-x-120">- </span><span 
class="cmmi-12">ab</span>] <span 
class="cmsy-10x-x-120">&#x2192; </span><span 
class="cmmi-12">inv</span>[1 <span 
class="cmsy-10x-x-120">- </span><span 
class="cmmi-12">ba</span>]<span 
class="cmmi-12">b</span>

<br class="newline">
<!--l. 351--><p class="indent">   The command NCS2R increases the range of expressions to include <span 
class="cmmi-12">inv</span>[<span 
class="cmmi-12">poly</span>], but the
reductions for each of these inverses is considerably less powerful than for the case of
<span 
class="cmmi-12">inv</span>[1 <span 
class="cmsy-10x-x-120">- </span><span 
class="cmmi-12">ab</span>].
<!--l. 356--><p class="indent">   An example: if <span 
class="cmmi-12">expr </span>= <span 
class="cmmi-12">a</span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">inv</span>[<span 
class="cmmi-12">a </span>+ <span 
class="cmmi-12">b</span>] + <span 
class="cmmi-12">inv</span>[<span 
class="cmmi-12">c</span><span 
class="cmsy-10x-x-120">-</span><span 
class="cmmi-12">a</span>] <span 
class="cmsy-10x-x-120">**</span>(<span 
class="cmmi-12">a</span><span 
class="cmsy-10x-x-120">-</span><span 
class="cmmi-12">c</span>) + <span 
class="cmmi-12">inv</span>[<span 
class="cmmi-12">c </span>+ <span 
class="cmmi-12">d</span>] <span 
class="cmsy-10x-x-120">**</span>(<span 
class="cmmi-12">c </span>+ <span 
class="cmmi-12">d </span>+ <span 
class="cmmi-12">e</span>), then the first
reduction using the list of rules in NCSR gives <span 
class="cmmi-12">a</span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">inv</span>[<span 
class="cmmi-12">a </span>+ <span 
class="cmmi-12">b</span>] + <span 
class="cmmi-12">inv</span>[<span 
class="cmmi-12">c </span>+ <span 
class="cmmi-12">d</span>] <span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">einv</span>[<span 
class="cmmi-12">a</span>] <span 
class="cmsy-10x-x-120">**</span>(<span 
class="cmmi-12">a</span><span 
class="cmsy-10x-x-120">-</span><span 
class="cmmi-12">b</span>) <span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">inv</span>[<span 
class="cmmi-12">b</span>]
and the second reduction gives <span 
class="cmmi-12">inv</span>[<span 
class="cmmi-12">b</span>] <span 
class="cmsy-10x-x-120">- </span><span 
class="cmmi-12">inv</span>[<span 
class="cmmi-12">a</span>] which is the output from <span 
class="cmmi-12">NCSR</span>[<span 
class="cmmi-12">expr</span>].
<!--l. 362--><p class="indent">   NCSimplify0Rational is an old attempt at simplification. We do not use it much.
<!--l. 381--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.2.1   </span> <a 
 id="x8-430004.2.1"></a>NCSimplifyRational[ expr ], NCSimplify1Rational[ expr ], and NCSimplify2Rational[
expr ]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">NCSR</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description:   The  objective  is  to  simplify  expressions  which  include  polynomials  and
      inverses of very simple polynomials. These work by appling a collection of relations
      implemented as rules to expr. The core of NCSimplifyRational is NCSimplify1Rational
      and       NCSimplify2Rational;       indeed       roughly       NCSimplifyRational[expr]
      = NCSimplify1Rational[NCSimplify2Rational[expr]] together with some NCExpand&#8217;s.
      NCSimplify1Rational[expr] contains one set of rules while NCSimplify2Rational[expr]
      contains another.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">expr </span>is an algebraic expression.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: Works only for a specialized class of functions. </dd></dl>
<a 
 id="dx8-43001"></a>
<!--l. 426--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.2.2   </span> <a 
 id="x8-440004.2.2"></a>NCSimplify1Rational[expr]</h4>

      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">NCS1R</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: It applies a collection of relations implemented as rules to <span 
class="cmmi-12">expr</span>. The goal is to
      simplify <span 
class="cmmi-12">expr</span>.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">expr </span>is an algebraic expression.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments                       /                       Limitations:                       <span 
class="cmbx-12">WARNING:</span>
      NCS1R does not first do an ExpandNonCommutativeMultiply. Therefore, it may be
      the  case  that  one  can  miss  some  simplification  if  <span 
class="cmmi-12">expr </span>is  not  expanded  out.  The
      solution, of course, is to call ExpandNonCommutativeMultiply before calling NCS1R.
      ExpandNonCommutativeMultiply is called from NCSR.
      <br class="newline">
      <br class="newline">&#x00A0;First, NCS1R normalizes <span 
class="cmmi-12">inv</span>[<span 
class="cmmi-12">S </span><span 
class="cmsy-10x-x-120">-</span><span 
class="cmmi-12">a</span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">b</span>] to <span 
class="cmmi-12">S</span><sup ><span 
class="cmsy-8">-</span><span 
class="cmr-8">1</span></sup> <span 
class="cmsy-10x-x-120">*</span><span 
class="cmmi-12">inv</span>[1 <span 
class="cmsy-10x-x-120">- </span>(<span 
class="cmmi-12">a</span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">b</span>)<span 
class="cmmi-12">&#x2215;S</span>] provided S is s a
      commutative expression (only works for numbers S in version 0.2 of NCAlgebra). The
      the following list of rules are applied.
      <br class="newline">(0) <span 
class="cmmi-12">inv</span>[<span 
class="cmsy-10x-x-120">-</span>1 + <span 
class="cmmi-12">a</span>] <span 
class="cmsy-10x-x-120">&#x2192;-</span><span 
class="cmmi-12">inv</span>[1 <span 
class="cmsy-10x-x-120">- </span><span 
class="cmmi-12">a</span>]
      <br class="newline">(1) <span 
class="cmmi-12">inv</span>[1 <span 
class="cmsy-10x-x-120">- </span><span 
class="cmmi-12">a</span>] (<span 
class="cmmi-12">a </span><span 
class="cmsy-10x-x-120">- </span><span 
class="cmmi-12">b</span>) <span 
class="cmmi-12">inv</span>[1 <span 
class="cmsy-10x-x-120">- </span><span 
class="cmmi-12">b</span>] <span 
class="cmsy-10x-x-120">&#x2192; </span><span 
class="cmmi-12">inv</span>[1 <span 
class="cmsy-10x-x-120">- </span><span 
class="cmmi-12">a</span>] <span 
class="cmsy-10x-x-120">- </span><span 
class="cmmi-12">inv</span>[1 <span 
class="cmsy-10x-x-120">- </span><span 
class="cmmi-12">b</span>]
      <br class="newline">(2) <span 
class="cmmi-12">inv</span>[1 <span 
class="cmsy-10x-x-120">- </span><span 
class="cmmi-12">ab</span>] <span 
class="cmmi-12">inv</span>[<span 
class="cmmi-12">b</span>] <span 
class="cmsy-10x-x-120">&#x2192; </span><span 
class="cmmi-12">inv</span>[1 <span 
class="cmsy-10x-x-120">- </span><span 
class="cmmi-12">ba</span>] <span 
class="cmmi-12">a </span>+ <span 
class="cmmi-12">inv</span>[<span 
class="cmmi-12">b</span>]
      <br class="newline">(3) <span 
class="cmmi-12">inv</span>[1 <span 
class="cmsy-10x-x-120">- </span><span 
class="cmmi-12">ab</span>] <span 
class="cmmi-12">ab </span><span 
class="cmsy-10x-x-120">&#x2192; </span><span 
class="cmmi-12">inv</span>[1 <span 
class="cmsy-10x-x-120">- </span><span 
class="cmmi-12">ab</span>] <span 
class="cmsy-10x-x-120">- </span>1
      <br class="newline">(4) <span 
class="cmmi-12">abinv</span>[1 <span 
class="cmsy-10x-x-120">- </span><span 
class="cmmi-12">ab</span>] <span 
class="cmsy-10x-x-120">&#x2192; </span><span 
class="cmmi-12">inv</span>[1 <span 
class="cmsy-10x-x-120">- </span><span 
class="cmmi-12">ab</span>] <span 
class="cmsy-10x-x-120">- </span>1
      <br class="newline">(5) <span 
class="cmmi-12">inv</span>[<span 
class="cmmi-12">c</span>] <span 
class="cmmi-12">inv</span>[1 <span 
class="cmsy-10x-x-120">- </span><span 
class="cmmi-12">cb</span>] <span 
class="cmsy-10x-x-120">&#x2192; </span><span 
class="cmmi-12">inv</span>[1 <span 
class="cmsy-10x-x-120">- </span><span 
class="cmmi-12">bc</span>] <span 
class="cmmi-12">inv</span>[<span 
class="cmmi-12">c</span>]
      <br class="newline">(6) <span 
class="cmmi-12">b inv</span>[1 <span 
class="cmsy-10x-x-120">- </span><span 
class="cmmi-12">ab</span>] <span 
class="cmsy-10x-x-120">&#x2192; </span><span 
class="cmmi-12">inv</span>[1 <span 
class="cmsy-10x-x-120">- </span><span 
class="cmmi-12">ba</span>]<span 
class="cmmi-12">b</span>
      <br class="newline">
      <br class="newline">In the notation of papers <span 
class="cmbx-12">[HW]</span>, <span 
class="cmbx-12">[HSW]</span>, these rules implement a superset of the union
      of the Gröbner basis for EB and the Gröbner basis for RESOL.  </dd></dl>
<a 
 id="dx8-44001"></a>
<!--l. 435--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.2.3   </span> <a 
 id="x8-450004.2.3"></a>NCSimplify2Rational[expr]</h4>

      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">NCS2R</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description:  You need this for expressions involving inv[ polynomial ] where the polynomial
      is not of the form <span 
class="cmmi-12">SId </span><span 
class="cmsy-10x-x-120">- </span><span 
class="cmmi-12">X </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">Y</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">expr </span>is an algebraic expression.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: If the polynomial is too complicated, this may not help very
      much. </dd></dl>
<a 
 id="dx8-45001"></a>
<!--l. 454--><p class="noindent">
   <h3 class="sectionHead"><span class="titlemark">4.3   </span> <a 
 id="x8-460004.3"></a>Vector Differentiation</h3>
<!--l. 463--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.3.1   </span> <a 
 id="x8-470004.3.1"></a>DirectionalD[expr, aVariable, h]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">DirD</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: Takes the Directional Derivative of expression <span 
class="cmmi-12">expr </span>with respect to the variable
      <span 
class="cmmi-12">aV ariable </span>in direction <span 
class="cmmi-12">h</span>.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">expr </span>is an expression containing var. <span 
class="cmmi-12">aV ariable </span>is a variable. <span 
class="cmmi-12">h </span>is the direction
      which the derivative is taken in.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: None. </dd></dl>
<a 
 id="dx8-47001"></a>
<a 
 id="dx8-47002"></a>

<!--l. 480--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.3.2   </span> <a 
 id="x8-480004.3.2"></a>Grad[expr, aVariable]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">Grad, NEVER USE Gradient</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: <span 
class="cmmi-12">Grad</span>[<span 
class="cmmi-12">expr,aV ariable</span>] takes the gradient of expression <span 
class="cmmi-12">expr </span>with respect to
      the variable <span 
class="cmmi-12">aV ariable</span>. Quite useful for computations with quadratic Hamiltonians in
      <span 
class="cmmi-12">H</span><sup ><span 
class="cmsy-8">&#x221E;</span></sup> control. BEWARE Gradient calls the Mma gradient and makes a mess.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments:  <span 
class="cmmi-12">expr </span>is an expression containing <span 
class="cmmi-12">var</span>. <span 
class="cmmi-12">aV ariable </span>is a variable.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: This only works reliably for quadratic expressions. It is not even
      correct on all of these. For example, <span 
class="cmmi-12">Grad</span>[<span 
class="cmmi-12">a </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x </span>+ <span 
class="cmmi-12">a </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">tp</span>[<span 
class="cmmi-12">x</span>]<span 
class="cmmi-12">,x</span>] returns 2<span 
class="cmmi-12">tp</span>[<span 
class="cmmi-12">a</span>]. The
      reason is fundamental mathematics, not programming. If <span 
class="cmmi-12">a </span>is a row vector and <span 
class="cmmi-12">x </span>is a
      column vector, then <span 
class="cmmi-12">a </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x </span>is a number, but <span 
class="cmmi-12">a </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">tp</span>[<span 
class="cmmi-12">x</span>] is not. </dd></dl>
<a 
 id="dx8-48001"></a>
<!--l. 490--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.3.3   </span> <a 
 id="x8-490004.3.3"></a>CriticalPoint[expr, aVariable]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">Crit, Cri</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: It finds the value of <span 
class="cmmi-12">aV ariable </span>which makes the gradient of the expression <span 
class="cmmi-12">expr</span>
      with respect to the variable <span 
class="cmmi-12">aV ariable </span>equal to 0.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">expr </span>is an expression containing <span 
class="cmmi-12">aV ariable</span>. <span 
class="cmmi-12">aV ariable </span>is a variable.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: Uses the Grad and NCSolve functions. Both Grad and NCSolve
      are severely limited. Therefore, the CriticalPoint command has a very limited range of
      applications. </dd></dl>

<a 
 id="dx8-49001"></a>
<!--l. 542--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.3.4   </span> <a 
 id="x8-500004.3.4"></a>NCHessian[afunction, <span 
class="cmsy-10x-x-120">{</span><span 
class="cmmi-12">X</span><sub ><span 
class="cmr-8">1</span></sub><span 
class="cmmi-12">,H</span><sub ><span 
class="cmr-8">1</span></sub><span 
class="cmsy-10x-x-120">}</span><span 
class="cmmi-12">,</span><span 
class="cmmi-12">&#x2026;</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{</span><span 
class="cmmi-12">X</span><sub ><span 
class="cmmi-8">k</span></sub><span 
class="cmmi-12">,H</span><sub ><span 
class="cmmi-8">k</span></sub><span 
class="cmsy-10x-x-120">} </span>]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None.</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: <span 
class="cmtt-12">NCHessian[afunction,</span><span 
class="cmsy-10x-x-120">{</span><span 
class="cmmi-12">X</span><sub ><span 
class="cmr-8">1</span></sub><span 
class="cmmi-12">,H</span><sub ><span 
class="cmr-8">1</span></sub><span 
class="cmsy-10x-x-120">}</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{</span><span 
class="cmmi-12">X</span><sub ><span 
class="cmr-8">2</span></sub><span 
class="cmmi-12">,H</span><sub ><span 
class="cmr-8">2</span></sub><span 
class="cmsy-10x-x-120">}</span><span 
class="cmmi-12">,</span><span 
class="cmmi-12">&#x2026;</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{</span><span 
class="cmmi-12">X</span><sub ><span 
class="cmmi-8">k</span></sub><span 
class="cmmi-12">,H</span><sub ><span 
class="cmmi-8">k</span></sub><span 
class="cmsy-10x-x-120">} </span><span 
class="cmtt-12">]</span>
      <br class="newline">computes the Hessian of a <span 
class="cmti-12">afunction </span>of noncommutting variables and coefficients. The
      Hessian recall is the second derivative. Here we are computing the noncommutative
      directional  derivative  of  a  noncommutative  function.  Using  repeated  calls  to
      <span 
class="cmtt-12">DirectionalD</span>, the Hessian of <span 
class="cmti-12">afunction </span>is computed with respect to the variables
      <span 
class="cmmi-12">X</span><sub ><span 
class="cmr-8">1</span></sub><span 
class="cmmi-12">,X</span><sub ><span 
class="cmr-8">2</span></sub><span 
class="cmmi-12">,</span><span 
class="cmmi-12">&#x2026;</span><span 
class="cmmi-12">,X</span><sub ><span 
class="cmmi-8">k</span></sub> and the search directions <span 
class="cmmi-12">H</span><sub ><span 
class="cmr-8">1</span></sub> , <span 
class="cmmi-12">H</span><sub ><span 
class="cmr-8">2</span></sub> , <span 
class="cmmi-12">&#x2026;</span> , <span 
class="cmmi-12">H</span><sub ><span 
class="cmmi-8">k</span></sub>. The Hessian <span 
class="cmsy-10x-x-120"><img 
src="cmsy10-c-48.png" alt="H" class="10-120x-x-48" /></span>&#x0393; of a function
      &#x0393; is defined by
      <center class="math-display" >
      <img 
src="NCBIGDOC16x.png" alt="               d2            &#x2223;
H &#x0393; (&#x20D7;X)[H&#x20D7;] :=  dt2&#x0393; (&#x20D7;X + t&#x20D7;H) &#x2223;t=0
      " class="math-display" ></center> One can easily show that the second derivative of a hereditary symmetric noncommutative
      rational function &#x0393; with respect to one variable <span 
class="cmmi-12">X </span>has the form
      <center class="math-display" >
      <img 
src="NCBIGDOC17x.png" alt="                  [                 ]
                    &#x2211;k      T
H &#x0393; (X)[H]  =  sym      A &#x2113;H  B &#x2113;HC  &#x2113;  ,
                    &#x2113;=1
      " class="math-display" ></center> where <span 
class="cmmi-12">A</span><sub ><span 
class="cmmi-8">&#x2113;</span></sub>, <span 
class="cmmi-12">B</span><sub ><span 
class="cmmi-8">&#x2113;</span></sub>, and <span 
class="cmmi-12">C</span><sub ><span 
class="cmmi-8">&#x2113;</span></sub> are functions of <span 
class="cmmi-12">X </span>determined by &#x0393;. (An analogous expression
      holds for more variables.) The Hessian will always be <span 
class="cmti-12">quadratic  </span>with respect to <img 
src="NCBIGDOC18x.png" alt="&#x20D7;H"  class="vec" >.
      (A <span 
class="cmti-12">noncommutative polynomial </span>in variables <span 
class="cmmi-12">H</span><sub ><span 
class="cmr-8">1</span></sub>, <span 
class="cmmi-12">H</span><sub ><span 
class="cmr-8">2</span></sub>, <span 
class="cmmi-12">&#x2026;</span> , <span 
class="cmmi-12">H</span><sub ><span 
class="cmmi-8">k</span></sub>, is said to be <span 
class="cmti-12">quadratic </span>if
      each monomial in the polynomial expression is of order two in the variables <span 
class="cmmi-12">H</span><sub ><span 
class="cmr-8">1</span></sub>, <span 
class="cmmi-12">H</span><sub ><span 
class="cmr-8">2</span></sub>,
      <span 
class="cmmi-12">&#x2026;</span>, <span 
class="cmmi-12">H</span><sub ><span 
class="cmmi-8">k</span></sub>.)
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmti-12">afunction </span>is a function of the variables <span 
class="cmmi-12">X</span><sub ><span 
class="cmr-8">1</span></sub><span 
class="cmmi-12">,X</span><sub ><span 
class="cmr-8">2</span></sub><span 
class="cmmi-12">,</span><span 
class="cmmi-12">&#x2026;</span><span 
class="cmmi-12">,X</span><sub ><span 
class="cmmi-8">k</span></sub>. The Hessian will be
      computed with respect to the search directions <span 
class="cmmi-12">H</span><sub ><span 
class="cmr-8">1</span></sub> , <span 
class="cmmi-12">H</span><sub ><span 
class="cmr-8">2</span></sub> , <span 
class="cmmi-12">&#x2026;</span> , <span 
class="cmmi-12">H</span><sub ><span 
class="cmmi-8">k</span></sub>.
      <br class="newline">For example, suppose <span 
class="cmmi-12">F</span>(<span 
class="cmmi-12">x,y</span>) = <span 
class="cmmi-12">x </span>+ <span 
class="cmmi-12">x </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">y </span>+ <span 
class="cmmi-12">y </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x</span>. Then,
      <br class="newline"><span 
class="cmtt-12">NCHessian</span>[<span 
class="cmmi-12">F,</span><span 
class="cmsy-10x-x-120">{</span><span 
class="cmmi-12">x,h</span><span 
class="cmsy-10x-x-120">}</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{</span><span 
class="cmmi-12">y,k</span><span 
class="cmsy-10x-x-120">}</span>] gives 2<span 
class="cmmi-12">h</span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">k </span>+ 2<span 
class="cmmi-12">k </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">h </span>As another example, if <span 
class="cmmi-12">G</span>(<span 
class="cmmi-12">x,y,z</span>) =
      <span 
class="cmmi-12">inv</span>[<span 
class="cmmi-12">y</span>] + <span 
class="cmmi-12">z </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x</span>, then <span 
class="cmtt-12">NCHessian</span>[<span 
class="cmmi-12">G,</span><span 
class="cmsy-10x-x-120">{</span><span 
class="cmmi-12">x,h</span><span 
class="cmsy-10x-x-120">}</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{</span><span 
class="cmmi-12">y,k</span><span 
class="cmsy-10x-x-120">}</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{</span><span 
class="cmmi-12">z,i</span><span 
class="cmsy-10x-x-120">}</span>] gives 2<span 
class="cmmi-12">i </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">h </span>+ 2<span 
class="cmmi-12">inv</span>[<span 
class="cmmi-12">y</span>] <span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">k </span><span 
class="cmsy-10x-x-120">*</span>
      <span 
class="cmsy-10x-x-120">*</span><span 
class="cmmi-12">inv</span>[<span 
class="cmmi-12">y</span>] <span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">k </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">inv</span>[<span 
class="cmmi-12">y</span>].
      <br class="newline">The  results  of  <span 
class="cmtt-12">NCHessian  </span>can  be  factored  into  the  form  <span 
class="cmmi-12">v</span><sup ><span 
class="cmmi-8">t</span></sup><span 
class="cmmi-12">Mv  </span>by  calling
      <span 
class="cmtt-12">NCMatrixofQuadratic</span>. (see <span 
class="cmtt-12">NCMatrixofQuadratic</span>).
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: None. </dd></dl>
<a 
 id="dx8-50001"></a>
<!--l. 544--><p class="noindent">
   <h3 class="sectionHead"><span class="titlemark">4.4   </span> <a 
 id="x8-510004.4"></a>Block Matrix Manipulation</h3>
<!--l. 546--><p class="noindent">By block matrices we mean matrices with noncommuting entries.
<!--l. 549--><p class="indent">   The Mathematica convention for handling vectors is tricky.

   <table width="100%" 
class="verbatim"><tr class="verbatim"><td 
class="verbatim"><div class="verbatim">
&#x00A0;&#x00A0;&#x00A0;v={{1,2,4}}
</div>
</td></tr></table>
<!--l. 552--><p class="nopar"> is a 1<span 
class="cmsy-10x-x-120">&#x00D7;</span>3 matrix or a row vector

   <table width="100%" 
class="verbatim"><tr class="verbatim"><td 
class="verbatim"><div class="verbatim">
&#x00A0;&#x00A0;&#x00A0;v={{1},{2},{4}}
</div>
</td></tr></table>
<!--l. 556--><p class="nopar"> is a 3<span 
class="cmsy-10x-x-120">&#x00D7;</span>1 matrix or a column vector

   <table width="100%" 
class="verbatim"><tr class="verbatim"><td 
class="verbatim"><div class="verbatim">
&#x00A0;&#x00A0;&#x00A0;v={1,2,4}
</div>
</td></tr></table>
<!--l. 560--><p class="nopar"> is a vector but NOT A MATRIX. Indeed whether it is a row or column vector depends on the
context. DON&#8217;T USE IT. Always remember to use TWO curly brackets on your vectors or there
will probably be trouble.
<!--l. 564--><p class="indent">   As of NCAlgebra version 3.2 one can handle block matrix manipulation two different ways. One
is the old way as described below where you use the command MatMult[A, B] to multiply block
matrices A and B and tpMat[A] to take transposes. The other way is much more pleasing though
still a little risky. First you use the <span 
class="cmbx-12">NCGuts[] </span>with the Options NCStrongProduct1 <span 
class="cmsy-10x-x-120">&#x2192;</span>
True to change <span 
class="cmsy-10x-x-120">** </span>to make block matrices multiply corectly. Further invoke the Option
NCStrongProduct2 <span 
class="cmsy-10x-x-120">&#x2192; </span>True to strengthen the power of <span 
class="cmsy-10x-x-120">**</span>. Now one does not have to use
MatMult and tpMat; just use <span 
class="cmsy-10x-x-120">** </span>and <span 
class="cmmi-12">tp </span>instead it recognizes matrix sizes and multiplies
correctly.
<!--l. 587--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.4.1   </span> <a 
 id="x8-520004.4.1"></a>MatMult[x, y, <span 
class="cmmi-12">&#x2026;</span>]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">MM</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description:   MatMult   multiplies   matrices.   The   Mathematica   code   executed   for
      <span 
class="cmmi-12">MatMult</span>[<span 
class="cmmi-12">x,y</span>] is Inner[ NonCommutativeMultiply, x, y, Plus];
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">x </span>is a block matrix, and <span 
class="cmmi-12">y </span>is a block matrix.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments  /  Limitations:  MatMult  can  take  any  number  of  input  parameters.  For
      example, <span 
class="cmtt-12">MatMult[a, b, c, d] </span>will give the same result as <span 
class="cmtt-12">MatMult[a, MatMult[b,</span>
      <span 
class="cmtt-12">MatMult[c, d]] ]</span>. </dd></dl>
<a 
 id="dx8-52001"></a>

<!--l. 595--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.4.2   </span> <a 
 id="x8-530004.4.2"></a>ajMat[u]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: <span 
class="cmmi-12">ajMat</span>[<span 
class="cmmi-12">u</span>] returns the transpose of the block matrix <span 
class="cmmi-12">u</span>. The Mathematica code
      is <span 
class="cmmi-12">Transpose</span>[<span 
class="cmmi-12">Map</span>[<span 
class="cmmi-12">aj</span>[#]&amp;<span 
class="cmmi-12">,u, </span>2]];
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">u </span>is a block <span 
class="cmmi-12">m </span><span 
class="cmsy-10x-x-120">&#x00D7; </span><span 
class="cmmi-12">n </span>matrix.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: None </dd></dl>
<a 
 id="dx8-53001"></a>
<!--l. 603--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.4.3   </span> <a 
 id="x8-540004.4.3"></a>coMat[u]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: <span 
class="cmmi-12">coMat</span>[<span 
class="cmmi-12">u</span>] returns the transpose of the block matrix <span 
class="cmmi-12">u</span>. The Mathematica code
      is [<span 
class="cmmi-12">Map</span>[<span 
class="cmmi-12">co</span>[#]&amp;<span 
class="cmmi-12">,u, </span>2]];
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">u </span>is a block <span 
class="cmmi-12">m </span><span 
class="cmsy-10x-x-120">&#x00D7; </span><span 
class="cmmi-12">n </span>matrix
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: None </dd></dl>
<a 
 id="dx8-54001"></a>

<!--l. 611--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.4.4   </span> <a 
 id="x8-550004.4.4"></a>tpMat[u]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: <span 
class="cmmi-12">tpMat</span>[<span 
class="cmmi-12">u</span>] returns the transpose of the block matrix <span 
class="cmmi-12">u</span>. The Mathematica is
      <span 
class="cmmi-12">Transpose</span>[<span 
class="cmmi-12">Map</span>[<span 
class="cmmi-12">tp</span>[#]&amp;<span 
class="cmmi-12">,u, </span>2]];
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">u </span>is a block <span 
class="cmmi-12">m </span><span 
class="cmsy-10x-x-120">&#x00D7; </span><span 
class="cmmi-12">n </span>matrix
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: None </dd></dl>
<a 
 id="dx8-55001"></a>
<!--l. 625--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.4.5   </span> <a 
 id="x8-560004.4.5"></a>NCMToMatMult[expr]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: Sometimes one develops an expression in which ** occurs between matrices.
      This command takes all ** and converts them to MatMult. The Mathematica code
      executed is expr//.NonCommutativeMultiply <span 
class="cmsy-10x-x-120">&#x2192; </span>MatMult;
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments:  <span 
class="cmmi-12">expr </span>is  an  algebraic  expression.  This  and  its  inverse  (TimesToNCM)  are
      important in manipulating block matrices. One can use
      <center class="math-display" >

      <img 
src="NCBIGDOC19x.png" alt="expr &#x2215;&#x2215;.N onCommutativeM    ultiply &#x2192; M  atM ult
      " class="math-display" ></center> instead of this command, since that is all that this command amounts to.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: None </dd></dl>
<a 
 id="dx8-56001"></a>
<!--l. 635--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.4.6   </span> <a 
 id="x8-570004.4.6"></a>TimesToNCM[expr]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">TTNCM</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description:            The            Mathematica            code            executed            is
      <span 
class="cmmi-12">expr&#x2215;.Times </span><span 
class="cmsy-10x-x-120">&#x2192; </span><span 
class="cmmi-12">NonCommutativeMultiply</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">expr </span>is an algebraic expression.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments   /   Limitations:   It   changes   commutative   multiplication   (Times)   to
      NonCommutative multiplication.  </dd></dl>
<a 
 id="dx8-57001"></a>
<!--l. 727--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.4.7   </span> <a 
 id="x8-580004.4.7"></a>Special Operations with Block Matrices</h4>
<!--l. 729--><p class="noindent">In 1999, we produced commands for LU decomposition and Cholesky decomposition of
an inversion of matrices with noncommutative entries. These replace older commands
<span 
class="cmti-12">GaussElimination[X]  </span>and <span 
class="cmti-12">invMat2[mat] </span>for 2 <span 
class="cmsy-10x-x-120">&#x00D7; </span>2 block matrices which are no longer documented.
The next 6 commands do that.

<!--l. 897--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.4.8   </span> <a 
 id="x8-590004.4.8"></a>NCLDUDecomposition[aMatrix, Options]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None.</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: NCLDUDecomposition[<span 
class="cmmi-12">X</span>] yields the LDU decomposition for a square matrix
      <span 
class="cmmi-12">X</span>. It returns a list of four elements, namely <span 
class="cmmi-12">L,D,U</span>, and <span 
class="cmmi-12">P </span>such that <span 
class="cmmi-12">PXP</span><sup ><span 
class="cmmi-8">T</span> </sup> = <span 
class="cmmi-12">LDU</span>.
      The first element is the lower triangular matrix <span 
class="cmmi-12">L</span>, the second element is the diagonal
      matrix <span 
class="cmmi-12">D</span>, the third element is the upper triangular matrix <span 
class="cmmi-12">U</span>, and the fourth is the
      permutation matrix <span 
class="cmmi-12">P </span>(the identity is returned if no permutation is needed). As an
      option, it may also return a list of the permutations used at each step of the LDU
      factorization as a fifth element.
      <br class="newline">
      <br class="newline">Suppose X is given by <span 
class="cmmi-12">X </span>= <span 
class="cmsy-10x-x-120">{{</span><span 
class="cmmi-12">a,b, </span>0<span 
class="cmsy-10x-x-120">}</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{</span>0<span 
class="cmmi-12">,c,d</span><span 
class="cmsy-10x-x-120">}</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{</span><span 
class="cmmi-12">a, </span>0<span 
class="cmmi-12">,d</span><span 
class="cmsy-10x-x-120">}}</span>. The command
      <center class="math-display" >
      <img 
src="NCBIGDOC20x.png" alt="{lo,di,up, P }=  N CLDU   Decomposition[X]
      " class="math-display" ></center> returns matrices, which in <span 
class="cmtt-12">MatrixForm </span>are:
      <br class="newline">
      <!--l. 897--><p class="noindent">
      <center class="math-display" >
      <img 
src="NCBIGDOC21x.png" alt="    (                     )                (                           )
       1        0       0                     a  0          0
lo = (  0        1       0 )           di = (  0  c          0          )
       1  - b * *inv[c] 1                     0  0  d + b * *inv[c] * *d
     (                            )       (           )
        1  inv[a] * *b     0                 1  0  0
up = (  0      1       inv[c] * *d )  P = (  0  1  0  )
        0      0           1                 0  0  1
      " class="math-display" ></center>
      <!--l. 897--><p class="noindent">As matrix <span 
class="cmmi-12">X </span>is 3<span 
class="cmsy-10x-x-120">&#x00D7;</span>3, one can provide 2 permutation matrices. Let those permutations
      be given by <span 
class="cmmi-12">l</span><sub ><span 
class="cmr-8">1</span></sub> = <span 
class="cmsy-10x-x-120">{</span>3<span 
class="cmmi-12">, </span>2<span 
class="cmmi-12">, </span>1<span 
class="cmsy-10x-x-120">} </span>and <span 
class="cmmi-12">l</span><sub ><span 
class="cmr-8">2</span></sub> = <span 
class="cmsy-10x-x-120">{</span>1<span 
class="cmmi-12">, </span>3<span 
class="cmmi-12">, </span>2<span 
class="cmsy-10x-x-120">}</span>, that means:
      <br class="newline">
      <!--l. 897--><p class="noindent">
      <center class="math-display" >
      <img 
src="NCBIGDOC22x.png" alt="      (          )         (          )
         0  0  1              1  0  0
P 1 = (  0  1  0 )   P 2 = (  0  0  1 )
         1  0  0              0  1  0
      " class="math-display" ></center>
      <!--l. 897--><p class="noindent">just as in <span 
class="cmtt-12">NCPermutationMatrix</span>. The command
      <center class="math-display" >
      <img 
src="NCBIGDOC23x.png" alt="{lo,di,up, P}=  N CLDU   Decomposition[X,   P ermutation  &#x2192;  {l1, l2}]
      " class="math-display" ></center> returns matrices, which in <span 
class="cmtt-12">MatrixForm </span>are:
      <br class="newline">
      <!--l. 897--><p class="noindent">

      <center class="math-display" >
      <img 
src="NCBIGDOC24x.png" alt="     (            )                        (              )
        1   0   0                             d  0    0
lo = (  0   1   0 )                   di = (  0  a    0   )
     (  1  - 1  1                 )        (  0  0  b +) c
        1  inv[d] * *a      0                 0  0  1
     (  0       1       inv[a] * *b )       (  1  0  0 )
up =                                  P  =               = P2 P1
        0       0           1                 0  1  0
      " class="math-display" ></center>
      <!--l. 897--><p class="noindent">It can be checked that <span 
class="cmmi-12">P</span><sup ><span 
class="cmmi-8">T</span> </sup> <span 
class="cmmi-12">lo di up P </span>= <span 
class="cmmi-12">X</span>:
      <center class="math-display" >
      <img 
src="NCBIGDOC25x.png" alt="M atM  ult[T ranspose[P ],lo, di,up, P ] = {{a, b,0},{0,c,d}, {a,0,d}}
      " class="math-display" ></center>
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: X is a square matrix n by n. The default Options are:
      <br class="newline"><span 
class="cmsy-10x-x-120">{</span><span 
class="cmtt-12">Permutation </span><span 
class="cmsy-10x-x-120">&#x2192; </span><span 
class="cmtt-12">False</span>, <span 
class="cmtt-12">CheckDecomposition  </span><span 
class="cmsy-10x-x-120">&#x2192; </span><span 
class="cmtt-12">False</span>,
      <br class="newline"><span 
class="cmtt-12">NCSimplifyPivots </span><span 
class="cmsy-10x-x-120">&#x2192; </span><span 
class="cmtt-12">False</span>, <span 
class="cmtt-12">StopAutoPermutation </span><span 
class="cmsy-10x-x-120">&#x2192; </span><span 
class="cmtt-12">False</span>,
      <br class="newline"><span 
class="cmtt-12">ReturnPermutation </span><span 
class="cmsy-10x-x-120">&#x2192; </span><span 
class="cmtt-12">False</span>,  <span 
class="cmtt-12">Stop2by2Pivoting </span><span 
class="cmsy-10x-x-120">&#x2192; </span><span 
class="cmtt-12">False </span><span 
class="cmsy-10x-x-120">}</span><span 
class="cmtt-12">. </span>If  permutation
      matrices are to be given, they should be provided as <span 
class="cmtt-12">Permutation </span><span 
class="cmsy-10x-x-120">&#x2192; {</span><span 
class="cmmi-12">l</span><sub ><span 
class="cmr-8">1</span></sub><span 
class="cmtt-12">, </span><span 
class="cmmi-12">l</span><sub ><span 
class="cmr-8">2</span></sub><span 
class="cmtt-12">,</span> <img 
src="NCBIGDOC26x.png" alt="&#x22C5;&#x22C5;&#x22C5;"  class="@cdots" ><span 
class="cmtt-12">,</span>
      <span 
class="cmmi-12">l</span><sub ><span 
class="cmmi-8">n</span></sub><span 
class="cmsy-10x-x-120">}</span>, where each <span 
class="cmmi-12">l</span><sub ><span 
class="cmmi-8">i</span></sub> is a list of integers (see the command <span 
class="cmtt-12">NCPermutationMatrix[]</span>). If
      <span 
class="cmtt-12">CheckDecomposition </span>is set to <span 
class="cmtt-12">True</span>, the function checks if <span 
class="cmmi-12">PXP</span><sup ><span 
class="cmmi-8">T</span> </sup> is identical to <span 
class="cmmi-12">LDU</span>.
      Where <span 
class="cmmi-12">P </span>= <span 
class="cmmi-12">P</span><sub ><span 
class="cmr-8">1</span></sub><span 
class="cmmi-12">P</span><sub ><span 
class="cmr-8">2</span></sub><img 
src="NCBIGDOC27x.png" alt="&#x22C5;&#x22C5;&#x22C5;"  class="@cdots" ><span 
class="cmmi-12">P</span><sub ><span 
class="cmmi-8">n</span></sub>, and each <span 
class="cmmi-12">P</span><sub ><span 
class="cmmi-8">i</span></sub> is the permutation matrix associated with each
      <span 
class="cmmi-12">l</span><sub ><span 
class="cmmi-8">i</span></sub>.
      <br class="newline">
      <br class="newline">Often a prospective pivot will appear to be nonzero in Mathematica even though
      it reduces to zero. To ensure we are not pivoting with a convoluted form of zero,

      we simplify the pivot at each step. By default, <span 
class="cmtt-12">NCLDUDecomposition </span>converts the
      pivot from non-commutative to commutative and then simplifies the expression. If
      the commutative form of the pivot simplifies to zero, Mathematica scrolls down the
      diagonal looking for a pivot which does not simplify to zero. If all the diagonal entries
      simplify to zero utilizing the <span 
class="cmtt-12">CommuteEverything[] </span>command, the process is repeated
      using <span 
class="cmtt-12">NCSimplifyRational</span>.
      <br class="newline">This strategy is incorporated for two main reasons. One is that for large matrices
      it  is  much  faster.  Secondly,  <span 
class="cmtt-12">NCSimplifyRational </span>does  not  always  completely
      simplify  complicated  expressions.  Setting  <span 
class="cmtt-12">NCSimplifyPivots </span><span 
class="cmsy-10x-x-120">&#x2192; </span><span 
class="cmtt-12">True </span>bypasses
      <span 
class="cmtt-12">CommuteEverything </span>and immediately applies
      <br class="newline"><span 
class="cmtt-12">NCSimplifyRational </span>to each pivot. <span 
class="cmtt-12">NCLDUDecomposition </span>will automatically pivot if
      the current pivot at a particular iteration is zero. If the user utilized the <span 
class="cmtt-12">Permutation</span>
      option, then the permutation designated will be temporarily disregarded. However,
      <span 
class="cmtt-12">NCLDUDecomposition </span>will try and use the given permutation list for the next step. In
      this way,
      <br class="newline"><span 
class="cmtt-12">NCLDUDecomposition  </span>follows  the  user  permutation  as  closely  as  possible.   If
      <span 
class="cmtt-12">StopAutoPermutation </span><span 
class="cmsy-10x-x-120">&#x2192; </span><span 
class="cmtt-12">True</span>,  then  <span 
class="cmtt-12">NCLDUDecomposition </span>will  not  automatically
      pivot and will strictly adhere to the user&#8217;s permutation, attempting to divide by zero
      if need be. This will allow the user to determine which permutations are not possible.
      Because <span 
class="cmtt-12">NCLDUDecomposition </span>will automatically pivot when necessary by default, the
      <span 
class="cmtt-12">ReturnPermutation  </span>was created so that the permutation used in the decomposition
      can be returned to the user for further analysis if set to <span 
class="cmtt-12">True</span>.
      <br class="newline">To explain the last option it is somewhat necessary for the user to have an idea of
      how the pivoting strategy works. The permutations used are always symmetrically
      applied. Because of this, we can only place other diagonal elements in the (1,1) position.
      However, it is possible to place any off diagonal element in the (2,1) position. Thus
      our strategy is to pivot only with diagonal elements if possible. If all the diagonal
      elements are zero, then a permutation matrix is used to place a nonzero entry in the
      (2,1) position which will automaticaly place a nonzero entry in the (1,2) position if
      the matrix is symmetric. Then, instead of using the (1,1) entry as a pivot, the 2<span 
class="cmsy-10x-x-120">&#x00D7;</span>2
      submatrix starting in the (1,1) position is used as a block pivot. This has the effect
      of creating an <span 
class="cmmi-12">LDU </span>decomposition where <span 
class="cmmi-12">D </span>is a block diagonal matrix with 1<span 
class="cmsy-10x-x-120">&#x00D7;</span>1 and
      2<span 
class="cmsy-10x-x-120">&#x00D7;</span>2 blocks along the diagonal. (Note: The pivots are precisely the diagonal entries
      of <span 
class="cmmi-12">D</span>.) Setting <span 
class="cmtt-12">Stop2by2Pivoting </span><span 
class="cmsy-10x-x-120">&#x2192; </span><span 
class="cmtt-12">True  </span>will halt 2 <span 
class="cmsy-10x-x-120">&#x00D7; </span>2 block pivoting, returning
      instead, the remaining undecomposed block with zeros along the diagonal as a final
      block diagonal entry.

      </dd><dt class="description">
 </dt><dd 
class="description">Comments  /  Limitations:   <span 
class="cmtt-12">NCLDUDecomposition </span>automatically  assumes  invertible  any
      expressions (pivot) it needs to be invertible. Also, the 2 <span 
class="cmsy-10x-x-120">&#x00D7; </span>2 pivoting strategy assumes
      that the matrix is symmetric in that it only ensures that the (2,1) entry is nonzero
      (assuming by symmetry that the (1,2) is also zero). The pivoting strategy chooses
      its pivots based upon the smallest leaf count invoking the Mathematica command
      <span 
class="cmtt-12">LeafCount[]</span>. It will choose the smallest nonzero diagonal element basing size upon
      the leaf count. This strategy is incorporated in an attempt to find the simplest <span 
class="cmmi-12">LDU</span>
      factorization possible. If a 2 <span 
class="cmsy-10x-x-120">&#x00D7; </span>2 pivot is used and <span 
class="cmtt-12">ReturnPermutation </span>is set to <span 
class="cmtt-12">True</span>
      then at the end of the permutation list returned will be the string 2by2 permutation.
      </dd></dl>
<a 
 id="dx8-59001"></a>
<!--l. 917--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.4.9   </span> <a 
 id="x8-600004.4.9"></a>NCAllPermutationLDU[aMatrix]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None.</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description:  <span 
class="cmmi-12">NCAllPermutationLDU</span>[<span 
class="cmmi-12">aMatrix</span>]  returns  the  LDU  decomposition  of  a
      matrix for all possible permutations. The code cycles through all possible permutations
      and calls <span 
class="cmtt-12">NCLDUDecomposition </span>for each one.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">aMatrix </span>is a square matrix. The default options for <span 
class="cmtt-12">NCAllPermutationLDU</span>
      are:    <span 
class="cmtt-12">PermutationSelection   </span><span 
class="cmsy-10x-x-120">&#x2192;  </span><span 
class="cmtt-12">False</span>,    <span 
class="cmtt-12">CheckDecomposition   </span><span 
class="cmsy-10x-x-120">&#x2192;  </span><span 
class="cmtt-12">False</span>,
      <span 
class="cmtt-12">NCSimplifyPivots </span><span 
class="cmsy-10x-x-120">&#x2192; </span><span 
class="cmtt-12">False</span>, <span 
class="cmtt-12">StopAutoPermutation </span><span 
class="cmsy-10x-x-120">&#x2192; </span><span 
class="cmtt-12">False</span>, <span 
class="cmtt-12">ReturnPermutation</span>
      <span 
class="cmsy-10x-x-120">&#x2192; </span><span 
class="cmtt-12">False</span>, <span 
class="cmtt-12">Stop2by2Pivoting </span><span 
class="cmsy-10x-x-120">&#x2192; </span><span 
class="cmtt-12">False</span>. All of these options have the same effect
      as in NCLDUDecomposition, except for PermutationSelection. PermutationSelection
      should  be  a  list  of  numbers  between  1  and  the  number  of  possible  permutations.
      NCAllPermutationLDU  will  use  this  list  to  choose  the  permutations  from  its
      canonical list to decompose the matrix using NCLDUDecomposition. For example,
      <span 
class="cmtt-12">PermutationSelection </span>can be <span 
class="cmsy-10x-x-120">{</span>1<span 
class="cmmi-12">,</span><span 
class="cmmi-12">&#x2026;</span><span 
class="cmmi-12">,n</span><span 
class="cmsy-10x-x-120">}</span>.

      </dd><dt class="description">
 </dt><dd 
class="description">Comments   /   Limitations:   The   output   is   a   list   of   all   successful   outputs   from
      <span 
class="cmtt-12">NCLDUDecomposition</span>. Note that some permutations may lead to a zero pivot in the
      process of doing the LDU decomposition. In that case, the LDU decomposition is not
      well defined, actually in Mathematica one gets a lot of <span 
class="cmsy-10x-x-120">&#x221E; </span>signs, but this output will
      not be included in the list of successful outputs.  </dd></dl>
<a 
 id="dx8-60001"></a>
<!--l. 935--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.4.10   </span> <a 
 id="x8-610004.4.10"></a>NCInverse[aSquareMatrix]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None.</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description:  NCInverse[<span 
class="cmmi-12">m</span>]  gives  a  symbolic  inverse  of  a  matrix  with  noncommutative
      entries.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">m </span>is an <span 
class="cmmi-12">n </span><span 
class="cmsy-10x-x-120">&#x00D7; </span><span 
class="cmmi-12">n </span>matrix with noncommutative entries.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments   /   Limitations:      This   command   is   primarily   used   symbolically   and
      is  not  guarenteed  to  work  for  any  specific  examples.  Usually  the  elements
      of   the   inverse   matrix   (<span 
class="cmmi-12">m</span><sup ><span 
class="cmsy-8">-</span><span 
class="cmr-8">1</span></sup>)   are   huge   expressions.   We   recommend   using
      <span 
class="cmtt-12">NCSimplifyRational[NCInverse[</span><span 
class="cmmi-12">m</span><span 
class="cmtt-12">]] </span>to improve the formula you get. In some cases,
      <span 
class="cmtt-12">NCSimplifyRational[</span><span 
class="cmmi-12">m</span><sup ><span 
class="cmsy-8">-</span><span 
class="cmr-8">1</span></sup><span 
class="cmmi-12">m</span><span 
class="cmtt-12">] </span>does not provide the identity matrix, even though it
      does equal the identity matrix. The formula we use for <span 
class="cmtt-12">NCInverse[] </span>comes from the
      LDU decomposition. Thus in principle it depends on the order chosen for pivoting even
      if the inverse of a matrix is unique. </dd></dl>
<a 
 id="dx8-61001"></a>
<!--l. 949--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.4.11   </span> <a 
 id="x8-620004.4.11"></a>NCPermutationMatrix[aListOfIntegers]</h4>

      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None.</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: <span 
class="cmmi-12">NCPermutationMatrix</span>[<span 
class="cmmi-12">aListOfIntegers</span>] returns the permutation matrix
      associated with the list of integers. It is just the identity matrix with its columns
      re-ordered.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">aListOfIntegers </span>is an encoding which specifies where the 1&#8217;s occur in each
      column. e.g., <span 
class="cmti-12">aListOfintegers </span>= <span 
class="cmsy-10x-x-120">{</span>2<span 
class="cmmi-12">, </span>4<span 
class="cmmi-12">, </span>3<span 
class="cmmi-12">, </span>1<span 
class="cmsy-10x-x-120">} </span>represents the permutation matrix
      <center class="math-display" >
      <img 
src="NCBIGDOC28x.png" alt="     &#x230A;             &#x230B;
       0   0  0  1
P  = || 1   0  0  0 ||
     &#x2308; 0   0  1  0 &#x2309;
       0   1  0  0
      " class="math-display" ></center>
      <!--l. 949--><p class="nopar">
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: None. </dd></dl>
<a 
 id="dx8-62001"></a>
<!--l. 964--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.4.12   </span> <a 
 id="x8-630004.4.12"></a>NCMatrixToPermutation[aMatrix]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None.</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: NCMatrixToPermutation[aMatrix] returns the permutation associated with
      the <span 
class="cmti-12">permutation matrix</span>, aMatrix. Basically, it is the inverse of <span 
class="cmtt-12">NCPermutationMatrix</span>.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: aMatrix must be matrix whose columns (or rows) can be permuted to yield the

      identity matrix. In other words, aMatrix must be a permutation matrix. For example,
      if m = <span 
class="cmsy-10x-x-120">{{</span>0<span 
class="cmmi-12">, </span>0<span 
class="cmmi-12">, </span>0<span 
class="cmmi-12">, </span>1<span 
class="cmsy-10x-x-120">}</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{</span>1<span 
class="cmmi-12">, </span>0<span 
class="cmmi-12">, </span>0<span 
class="cmmi-12">, </span>0<span 
class="cmsy-10x-x-120">}</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{</span>0<span 
class="cmmi-12">, </span>0<span 
class="cmmi-12">, </span>1<span 
class="cmmi-12">, </span>0<span 
class="cmsy-10x-x-120">}</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{</span>0<span 
class="cmmi-12">, </span>1<span 
class="cmmi-12">, </span>0<span 
class="cmmi-12">, </span>0<span 
class="cmsy-10x-x-120">}}</span>, then <span 
class="cmtt-12">NCPermutationMatrix</span>[m]
      gives <span 
class="cmsy-10x-x-120">{</span>2<span 
class="cmmi-12">, </span>4<span 
class="cmmi-12">, </span>3<span 
class="cmmi-12">, </span>1<span 
class="cmsy-10x-x-120">}</span>.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: None. </dd></dl>
<a 
 id="dx8-63001"></a>
<!--l. 977--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.4.13   </span> <a 
 id="x8-640004.4.13"></a>NCCheckPermutation[SizeOfMatrix, aListOfPermutations]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None.</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: If <span 
class="cmtt-12">aListOfPermutations </span>is consistent with the matrix size, <span 
class="cmtt-12">SizeOfMatrix</span>,
      then  the  output  is  <span 
class="cmtt-12">valid permutation list</span>.  If  not,  the  output  is  <span 
class="cmtt-12">not valid</span>
      <span 
class="cmtt-12">permutation list</span>.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: The size of a square matrix (an integer) and a list of permutations.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments  /  Limitations:  If  the  <span 
class="cmtt-12">SizeOfMatrix </span>is  n,  then  <span 
class="cmtt-12">aListOfPermutations </span>must
      be a list of <span 
class="cmmi-12">n </span><span 
class="cmsy-10x-x-120">- </span>1 permutations of the integers 1 through <span 
class="cmmi-12">n</span>. Since this command is
      generally called within the context of <span 
class="cmtt-12">NCLDUDecomposition </span>the list of permutations
      must correspond to a list that can be used within the command. </dd></dl>
<a 
 id="dx8-64001"></a>
<!--l. 984--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.4.14   </span> <a 
 id="x8-650004.4.14"></a>Diag[aMatrix]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None.</span>

      </dd><dt class="description">
 </dt><dd 
class="description">Description: Returns the elements of the diagonal of a matrix.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: None.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: The code is Flatten[MapIndexed[Part,m]]. </dd></dl>
<a 
 id="dx8-65001"></a>
<!--l. 1025--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.4.15   </span> <a 
 id="x8-660004.4.15"></a>Cascade[P, K]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: <span 
class="cmmi-12">Cascade</span>[<span 
class="cmmi-12">P,K</span>] is the composition of <span 
class="cmmi-12">P</span>, <span 
class="cmmi-12">K </span>as is found is systems engineering.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">P </span>is a 2<span 
class="cmsy-10x-x-120">&#x00D7;</span>2 block matrix. <span 
class="cmmi-12">K </span>is a symbol.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: frequency response functions grow from this.  </dd></dl>
<a 
 id="dx8-66001"></a>
<!--l. 1033--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.4.16   </span> <a 
 id="x8-670004.4.16"></a>Chain[P]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: <span 
class="cmmi-12">Chain</span>[<span 
class="cmmi-12">P</span>] returns the chain matrix arising from <span 
class="cmmi-12">P  </span>as is found in systems
      engineering.

      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">P </span>is a block 2<span 
class="cmsy-10x-x-120">&#x00D7;</span>2 matrix.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: Chain[ ] assumes appropriate matrices are invertible. </dd></dl>
<a 
 id="dx8-67001"></a>
<!--l. 1041--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.4.17   </span> <a 
 id="x8-680004.4.17"></a>Redheffer[P]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: <span 
class="cmmi-12">Redheffer</span>[<span 
class="cmmi-12">P</span>] gives the inverse of chain.
      <br class="newline">Redheffer[<span 
class="cmmi-12">Chain</span>[<span 
class="cmmi-12">P</span>]] = <span 
class="cmmi-12">P </span>= <span 
class="cmmi-12">Chain</span>[Redheffer[<span 
class="cmmi-12">P</span>]].
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">P </span>is a block 2 <span 
class="cmsy-10x-x-120">&#x00D7; </span>2 matrix.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: <span 
class="cmmi-12">Redheffer</span>[<span 
class="cmmi-12">P</span>] assumes the invertiblity of the entries of <span 
class="cmmi-12">P</span>. </dd></dl>
<a 
 id="dx8-68001"></a>
<!--l. 1051--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.4.18   </span> <a 
 id="x8-690004.4.18"></a>DilationHalmos[x]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: <span 
class="cmmi-12">DilationHalmos</span>[<span 
class="cmmi-12">x</span>] gives block 2 <span 
class="cmsy-10x-x-120">&#x00D7; </span>2 matrix which is the Halmos dilation of
      <span 
class="cmmi-12">x</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">x </span>is a symbol

      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: <span 
class="cmmi-12">u </span>=  <span 
class="cmmi-12">DilationHalmos</span>[<span 
class="cmmi-12">x</span>] has the property <span 
class="cmmi-12">u </span>is unitary, that
      is,  <span 
class="cmmi-12">MatMult</span>[<span 
class="cmmi-12">u,tpMat</span>[<span 
class="cmmi-12">u</span>]]  ==  <span 
class="cmmi-12">IdentityMatrix</span>[2]  and  <span 
class="cmmi-12">MatMult</span>[<span 
class="cmmi-12">tpMat</span>[<span 
class="cmmi-12">u</span>]<span 
class="cmmi-12">,u</span>]  ==
      <span 
class="cmmi-12">IdentityMatrix</span>[2].  </dd></dl>
<a 
 id="dx8-69001"></a>
<!--l. 1061--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.4.19   </span> <a 
 id="x8-700004.4.19"></a>SchurComplementTop[M]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: <span 
class="cmmi-12">SchurComplementTop</span>[<span 
class="cmmi-12">M</span>] returns the Shur Complement of the top diagonal
      entry of a block 2 <span 
class="cmsy-10x-x-120">&#x00D7; </span>2 matrix <span 
class="cmmi-12">M</span>.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">M </span>is a block 2 <span 
class="cmsy-10x-x-120">&#x00D7; </span>2 matrix.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: Assumes invertibility of a diagonal entry. </dd></dl>
<a 
 id="dx8-70001"></a>
<!--l. 1069--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.4.20   </span> <a 
 id="x8-710004.4.20"></a>SchurComplementBtm[M]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description:  <span 
class="cmmi-12">SchurComplementBtm</span>[<span 
class="cmmi-12">M</span>]  returns  the  ShurComplement  of  the  bottom
      diagonal entry of a block 2 <span 
class="cmsy-10x-x-120">&#x00D7; </span>2 matrix <span 
class="cmmi-12">M</span>.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">M </span>is a block 2 <span 
class="cmsy-10x-x-120">&#x00D7; </span>2 matrix.

      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: Assumes invertibility of a diagonal entry. </dd></dl>
<a 
 id="dx8-71001"></a>
<!--l. 1071--><p class="noindent">
   <h3 class="sectionHead"><span class="titlemark">4.5   </span> <a 
 id="x8-720004.5"></a>Complex Analysis</h3>
<!--l. 1073--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.5.1   </span> <a 
 id="x8-730004.5.1"></a>A tutorial</h4>
<!--l. 1075--><p class="noindent">The package in the file ComplexRules.m defines three objects:
      <dl class="description"><dt class="description">
 </dt><dd 
class="description"><span 
class="cmsy-10x-x-120">&#x2219; </span>ComplexRules,&#x00A0;&#x00A0;&#x00A0;&#x00A0;transformation rules
      </dd><dt class="description">
 </dt><dd 
class="description"><span 
class="cmsy-10x-x-120">&#x2219; </span>ComplexCoordinates, &#x00A0;&#x00A0;&#x00A0;&#x00A0;a function that applies rules to an expression.
      </dd><dt class="description">
 </dt><dd 
class="description"><span 
class="cmsy-10x-x-120">&#x2219; </span>ComplexD[],&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;takes complex derivatives.</dd></dl>
<!--l. 1084--><p class="indent">   The ComplexRules package is for handling complex algebra and differentiation. The algebra
part of ComplexRules has been pretty much superceeded by the standard Mathematica command
<span class="obeylines-h"><span class="verb"><span 
class="cmtt-12">ComplexExpand[]</span></span></span> so we advise using that. Our complex differentiation is still quite useful.
ComplexRules.m may not work well with ReIm.m, see the warning at the end of this
note.

   <table width="100%" 
class="verbatim"><tr class="verbatim"><td 
class="verbatim"><div class="verbatim">
In[1]:=&#x00A0;&lt;&lt;ComplexRules&#8216;
&#x00A0;<br />In[2]:=&#x00A0;y&#x00A0;=&#x00A0;Re[(e&#x00A0;+&#x00A0;w&#x00A0;z&#x00A0;)&#x02C6;2]&#x02C6;2
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;2&#x00A0;2
&#x00A0;<br />Out[2]=&#x00A0;Re[(e&#x00A0;+&#x00A0;w&#x00A0;z)&#x00A0;]
</div>
</td></tr></table>
<!--l. 1095--><p class="nopar">
<!--l. 1097--><p class="indent">   To rewrite this in terms of variables and their conjugates, apply the list of rules <span 
class="cmmi-12">ComplexRules</span>
as follows

   <table width="100%" 
class="verbatim"><tr class="verbatim"><td 
class="verbatim"><div class="verbatim">
In[3]:=&#x00A0;y&#x00A0;//.&#x00A0;ComplexRules
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;2&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;2&#x00A0;2
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;((e&#x00A0;+&#x00A0;w&#x00A0;z)&#x00A0;&#x00A0;+&#x00A0;(Conjugate[e]&#x00A0;+&#x00A0;Conjugate[w]&#x00A0;Conjugate[z])&#x00A0;)
&#x00A0;<br />Out[3]=&#x00A0;-----------------------------------------------------------
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;4
</div>
</td></tr></table>
<!--l. 1107--><p class="nopar">
<!--l. 1109--><p class="indent">   You can get the same result with the function ComplexCoordinates[]:

   <table width="100%" 
class="verbatim"><tr class="verbatim"><td 
class="verbatim"><div class="verbatim">
In[4]:=&#x00A0;ComplexCoordinates[y]
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;2&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;2&#x00A0;2
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;((e&#x00A0;+&#x00A0;w&#x00A0;z)&#x00A0;&#x00A0;+&#x00A0;(Conjugate[e]&#x00A0;+&#x00A0;Conjugate[w]&#x00A0;Conjugate[z])&#x00A0;)
&#x00A0;<br />Out[4]=&#x00A0;-----------------------------------------------------------
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;4
&#x00A0;<br />
</div>
</td></tr></table>
<!--l. 1119--><p class="nopar">
<!--l. 1121--><p class="indent">   Suppose that you know that in the expression above, <span 
class="cmmi-12">e </span>ranges in the unit circle of the complex
plane, and that <span 
class="cmmi-12">w </span>is real. To simplify you can do this:

   <table width="100%" 
class="verbatim"><tr class="verbatim"><td 
class="verbatim"><div class="verbatim">
In[5]:=&#x00A0;%&#x00A0;/.&#x00A0;{Conjugate[e]-&gt;1/e,Conjugate[w]-&gt;w}
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;2&#x00A0;&#x00A0;&#x00A0;&#x00A0;1&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;2&#x00A0;2
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;((e&#x00A0;+&#x00A0;w&#x00A0;z)&#x00A0;&#x00A0;+&#x00A0;(-&#x00A0;+&#x00A0;w&#x00A0;Conjugate[z])&#x00A0;)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;e
&#x00A0;<br />Out[5]=&#x00A0;-------------------------------------
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;4
</div>
</td></tr></table>
<!--l. 1133--><p class="nopar">
<!--l. 1135--><p class="indent">   Complex derivatives are easy to produce with ComplexD[]:

   <table width="100%" 
class="verbatim"><tr class="verbatim"><td 
class="verbatim"><div class="verbatim">
&#x00A0;<br />In[6]:=&#x00A0;ComplexD[&#x00A0;y&#x00A0;,&#x00A0;z]
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;2
&#x00A0;<br />Out[6]=&#x00A0;w&#x00A0;(e&#x00A0;+&#x00A0;w&#x00A0;z)&#x00A0;((e&#x00A0;+&#x00A0;w&#x00A0;z)
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;2
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;+&#x00A0;(Conjugate[e]&#x00A0;+&#x00A0;Conjugate[w]&#x00A0;Conjugate[z])&#x00A0;)
&#x00A0;<br />
</div>
</td></tr></table>
<!--l. 1146--><p class="nopar">
<!--l. 1148--><p class="indent">   Here is a differentiation with respect to Conjugate[w]:

   <table width="100%" 
class="verbatim"><tr class="verbatim"><td 
class="verbatim"><div class="verbatim">
&#x00A0;<br />In[7]:=&#x00A0;ComplexD[&#x00A0;y&#x00A0;,&#x00A0;Conjugate[w]]
&#x00A0;<br />
&#x00A0;<br />Out[7]=&#x00A0;Conjugate[z]&#x00A0;(Conjugate[e]&#x00A0;+&#x00A0;Conjugate[w]&#x00A0;Conjugate[z])
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;2&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;2
&#x00A0;<br />&gt;&#x00A0;&#x00A0;&#x00A0;&#x00A0;((e&#x00A0;+&#x00A0;w&#x00A0;z)&#x00A0;&#x00A0;+&#x00A0;(Conjugate[e]&#x00A0;+&#x00A0;Conjugate[w]&#x00A0;Conjugate[z])&#x00A0;)
&#x00A0;<br />
</div>
</td></tr></table>
<!--l. 1159--><p class="nopar">
<!--l. 1161--><p class="indent">   A mixed second order partial derivative is shown below:

   <table width="100%" 
class="verbatim"><tr class="verbatim"><td 
class="verbatim"><div class="verbatim">
&#x00A0;<br />In[8]:=&#x00A0;ComplexD[&#x00A0;y&#x00A0;,&#x00A0;Conjugate[z]&#x00A0;,&#x00A0;z]
&#x00A0;<br />
&#x00A0;<br />Out[8]=&#x00A0;2&#x00A0;w&#x00A0;(e&#x00A0;+&#x00A0;w&#x00A0;z)&#x00A0;Conjugate[w]
&#x00A0;<br />
&#x00A0;<br />&gt;&#x00A0;&#x00A0;&#x00A0;&#x00A0;(Conjugate[e]&#x00A0;+&#x00A0;Conjugate[w]&#x00A0;Conjugate[z])
&#x00A0;<br />
</div>
</td></tr></table>
<!--l. 1171--><p class="nopar">
<!--l. 1173--><p class="indent">   Repeated differentiation is also possible:

   <table width="100%" 
class="verbatim"><tr class="verbatim"><td 
class="verbatim"><div class="verbatim">
&#x00A0;<br />In[9]:=&#x00A0;ComplexD[&#x00A0;y&#x00A0;,&#x00A0;{Conjugate[z],2}]
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;2&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;2
&#x00A0;<br />Out[9]=&#x00A0;2&#x00A0;Conjugate[w]&#x00A0;&#x00A0;(Conjugate[e]&#x00A0;+&#x00A0;Conjugate[w]&#x00A0;Conjugate[z])&#x00A0;&#x00A0;+
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;2&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;2
&#x00A0;<br />&gt;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Conjugate[w]&#x00A0;&#x00A0;((e&#x00A0;+&#x00A0;w&#x00A0;z)&#x00A0;&#x00A0;+&#x00A0;(Conjugate[e]&#x00A0;+&#x00A0;Conjugate[w]
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;2
&#x00A0;<br />&gt;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Conjugate[z])&#x00A0;)
</div>
</td></tr></table>
<!--l. 1187--><p class="nopar">
<!--l. 1189--><p class="indent">   Finally, we point out that it is possible that applying ComplexRules to an expression and
applying ComplexCoordinates to it may yield different output (the same mathematically of
course). Reason: ComplexCoordinates applies ComplexRules to the expression, in addition to a
rule for transforming Abs[z] into Sqrt[ z Conjugate[z]]. Example:

   <table width="100%" 
class="verbatim"><tr class="verbatim"><td 
class="verbatim"><div class="verbatim">
In[10]:=&#x00A0;Abs[z&#x02C6;2&#x00A0;+&#x00A0;1]&#x02C6;2&#x00A0;//.&#x00A0;ComplexRules
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;2&#x00A0;2
&#x00A0;<br />Out[10]=&#x00A0;Abs[1&#x00A0;+&#x00A0;z&#x00A0;]
&#x00A0;<br />
&#x00A0;<br />In[11]:=&#x00A0;ComplexCoordinates[&#x00A0;%&#x00A0;]
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;2&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;2
&#x00A0;<br />Out[11]=&#x00A0;(1&#x00A0;+&#x00A0;z&#x00A0;)&#x00A0;(1&#x00A0;+&#x00A0;Conjugate[z]&#x00A0;)
</div>
</td></tr></table>
<!--l. 1201--><p class="nopar">
<!--l. 1204--><p class="indent">   ComplexD[] handles <span 
class="cmmi-12">Abs</span>[]<sup ><span 
class="cmr-8">2</span></sup> etc.:

   <table width="100%" 
class="verbatim"><tr class="verbatim"><td 
class="verbatim"><div class="verbatim">
&#x00A0;<br />In[12]:=&#x00A0;ComplexD[&#x00A0;Abs[z&#x02C6;2&#x00A0;+&#x00A0;1]&#x02C6;2,z]
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;2
&#x00A0;<br />Out[12]=&#x00A0;2&#x00A0;z&#x00A0;(1&#x00A0;+&#x00A0;Conjugate[z]&#x00A0;)
&#x00A0;<br />
</div>
</td></tr></table>
<!--l. 1213--><p class="nopar">
<!--l. 1215--><p class="indent">   ComplexD[] also handles <span 
class="cmmi-12">Abs</span>[]<sup ><span 
class="cmr-8">1</span></sup> but the answer does not look as pretty:

   <table width="100%" 
class="verbatim"><tr class="verbatim"><td 
class="verbatim"><div class="verbatim">
In[13]:=&#x00A0;ComplexD[&#x00A0;Abs[z&#x02C6;2&#x00A0;+&#x00A0;1],z]
&#x00A0;<br />
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;2
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;z&#x00A0;(1&#x00A0;+&#x00A0;Conjugate[z]&#x00A0;)
&#x00A0;<br />Out[13]=&#x00A0;----------------------------------
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;2&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;2
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;&#x00A0;Sqrt[(1&#x00A0;+&#x00A0;z&#x00A0;)&#x00A0;(1&#x00A0;+&#x00A0;Conjugate[z]&#x00A0;)]
&#x00A0;<br />
</div>
</td></tr></table>
<!--l. 1226--><p class="nopar">
<!--l. 1229--><p class="noindent"><span 
class="cmbx-12">WARNING: </span>The standard Mathematica package ReIm.m sets things so that expressions of
complex variables &#8220;z&#8221; are rewritten in terms of Re[z], Im[z] (for example).
<!--l. 1235--><p class="indent">   Compare this to the output of functions in the package ComplexRules.m, where the expressions
of complex variables &#8220;z&#8221; are given in terms of z, Conjugate[z].
<!--l. 1239--><p class="indent">   You may load both ReIm.m and ComplexRules.m, but keep in mind that the objectives of the
packages conflict. Furthermore, programs that need ComplexRules to run will sometimes not work
if ReIm.m has been loaded.
<!--l. 1244--><p class="indent">   Mathematica can manipulate complex analysis via X + I Y where X and Y are
commutative (e.g., numbers). However, it is often more convenient to calculate in terms of z
and the conjugate of z. We implement a few commands in the file NCComplex.m. We
discuss these commands below. One may also look at the file NCComplex.m for further
documentation.
<!--l. 1263--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.5.2   </span> <a 
 id="x8-740004.5.2"></a>ComplexRules</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: <span 
class="cmmi-12">ComplexRules </span>is a set of replacement rules for writing expressions in terms

      of  the  variables  and  their  complex  conjugates.  For  example,  use  this  with  input
      containing numbers and variables, as well as operators/functions such as + <span 
class="cmsy-10x-x-120">- * </span><span 
class="cmmi-12">&#x2215;</span>,
      Re[], Im[], Conjugate[], Exp[], Power[], Sin[], Cos[] and others. Apply the command
      expr//.ComplexRules. Try the following example:
      <br class="newline"><span 
class="cmmi-12">Re</span>[(1 + <span 
class="cmmi-12">zw</span>)<sup ><span 
class="cmr-8">2</span></sup>]<sup ><span 
class="cmr-8">2</span></sup> //.ComplexRules
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: None
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: This only works for expressions defined with the commutative
      multiplication. </dd></dl>
<a 
 id="dx8-74001"></a>
<!--l. 1275--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.5.3   </span> <a 
 id="x8-750004.5.3"></a>ComplexCoordinates[expr]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description:  <span 
class="cmmi-12">ComplexCoordinates</span>[<span 
class="cmmi-12">expr</span>]  expands  <span 
class="cmmi-12">expr  </span>in  terms  of  the  variables  and
      their  complex  conjugates.  The  difference  between  <span 
class="cmmi-12">ComplexCoordinates</span>[<span 
class="cmmi-12">expr</span>]  and
      <span 
class="cmmi-12">ComplexRules </span>is in the case <span 
class="cmmi-12">Abs</span>[<span 
class="cmmi-12">z</span>]<sup ><span 
class="cmr-8">2</span></sup>//.ComplexRules. This case returns the same
      expression instead of z and Conjugate[z]. If you desire to use the latter expression,
      you  can  use  ComplexCoordinates[expr].  This  function  replaces  Abs[z]  by  Sqrt[z
      Conjugate[z]], after applying ComplexRules.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">expr </span>is any expression with + <span 
class="cmsy-10x-x-120">- * </span><span 
class="cmmi-12">&#x2215;</span>, Re[], Im[], Conjugate[], Exp[], Power[],
      Sin[], Cos[] and others
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: This only works for expressions defined with the commutative
      multiplication. </dd></dl>
<a 
 id="dx8-75001"></a>

<!--l. 1301--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.5.4   </span> <a 
 id="x8-760004.5.4"></a>ComplexD[expr, aVariable]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: <span 
class="cmmi-12">ComplexD</span>[<span 
class="cmmi-12">expr,aV ariable</span>] calculates the derivative of the complex expression
      <span 
class="cmmi-12">expr </span>with respect to the &#8220;complex&#8221; variable <span 
class="cmmi-12">aV ariable</span>. You can also calculate the
      derivative with respect to <span 
class="cmmi-12">Conjugate</span>[<span 
class="cmmi-12">aV ariable</span>]. Try these examples:
      <br class="newline">
      <br class="newline"><span 
class="cmmi-12">ComplexD</span>[<span 
class="cmmi-12">Conjugate</span>[<span 
class="cmmi-12">Exp</span>[<span 
class="cmmi-12">z </span>+ 1<span 
class="cmmi-12">&#x2215;Conjugate</span>[<span 
class="cmmi-12">z</span>]]<sup ><span 
class="cmr-8">2</span></sup>]<span 
class="cmmi-12">,z</span>];
      <br class="newline"><span 
class="cmmi-12">ComplexD</span>[<span 
class="cmmi-12">Re</span>[(1 + <span 
class="cmmi-12">zw</span>)<sup ><span 
class="cmr-8">2</span></sup>]<sup ><span 
class="cmr-8">2</span></sup><span 
class="cmmi-12">,w</span>];
      <br class="newline"><span 
class="cmmi-12">ComplexD</span>[<span 
class="cmmi-12">Abs</span>[1<span 
class="cmmi-12">&#x2215;</span>(<span 
class="cmmi-12">e</span><sup ><span 
class="cmr-8">2</span></sup> <span 
class="cmsy-10x-x-120">- </span>1) <span 
class="cmsy-10x-x-120">- </span><span 
class="cmmi-12">z</span>]<sup ><span 
class="cmr-8">2</span></sup><span 
class="cmmi-12">,z</span>];
      <br class="newline"><span 
class="cmmi-12">ComplexD</span>[<span 
class="cmmi-12">Conjugate</span>[<span 
class="cmmi-12">Exp</span>[<span 
class="cmmi-12">z </span>+ 1<span 
class="cmmi-12">&#x2215;Conjugate</span>[<span 
class="cmmi-12">z</span>]]<sup ><span 
class="cmr-8">2</span></sup>]<span 
class="cmmi-12">,Conjugate</span>[<span 
class="cmmi-12">z</span>]];
      <br class="newline">
      <br class="newline">Here is a second order derivative:
      <br class="newline">
      <br class="newline"><span 
class="cmmi-12">ComplexD</span>[<span 
class="cmmi-12">Conjugate</span>[<span 
class="cmmi-12">Exp</span>[<span 
class="cmmi-12">z </span>+ 1<span 
class="cmmi-12">&#x2215;Conjugate</span>[<span 
class="cmmi-12">z</span>]]<sup ><span 
class="cmr-8">2</span></sup><span 
class="cmmi-12">,</span><span 
class="cmmi-12">z, </span>2];
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">expr </span>is a complex expression. <span 
class="cmmi-12">aV ariable </span>is the variable in which to take the
      derivative with respect to.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: This only works for expressions defined with the commutative
      multiplication. </dd></dl>
<a 
 id="dx8-76001"></a>
<!--l. 1303--><p class="noindent">
   <h3 class="sectionHead"><span class="titlemark">4.6   </span> <a 
 id="x8-770004.6"></a>Setting symbols to commute or not commute</h3>
<!--l. 1316--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.6.1   </span> <a 
 id="x8-780004.6.1"></a>SetNonCommutative[A, B, C, <span 
class="cmmi-12">&#x2026;</span>]</h4>

      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">SNC, SetNC</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description:  SetNonCommutative[A,  B,  C,  <span 
class="cmmi-12">&#x2026;</span>]  sets  all  the  symbols  <span 
class="cmmi-12">A</span>,  <span 
class="cmmi-12">B</span>,  <span 
class="cmmi-12">C</span>,  <span 
class="cmmi-12">&#x2026;</span> to  be
      noncommutative. The lower case letters <span 
class="cmmi-12">a</span>, <span 
class="cmmi-12">b</span>, <span 
class="cmmi-12">c</span>, <span 
class="cmmi-12">&#x2026;</span> are assumed noncommutative by
      Mathematica default as are functions of noncommutative variables. The functions <span 
class="cmmi-12">tp</span>[]
      and <span 
class="cmmi-12">aj</span>[] are set noncommutative by NCAlgebra for any argument, commutative or
      noncommutative. We may change this.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: Symbols separated by commas
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: None </dd></dl>
<a 
 id="dx8-78001"></a>
<!--l. 1328--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.6.2   </span> <a 
 id="x8-790004.6.2"></a>CommuteEverything[expr]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">CE</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: It changes NonCommutativeMultiply to Times in <span 
class="cmmi-12">expr</span>.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">expr </span>is an algebraic expression.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations:   Very useful for getting ideas in the middle of a complicated
      calcuation. If <span 
class="cmmi-12">expr </span>has you baffled, type <span 
class="cmmi-12">exprcom </span>= <span 
class="cmmi-12">CE</span>[<span 
class="cmmi-12">expr</span>]. <span 
class="cmmi-12">exprcom </span>is commutative
      and therefore is easy to analyze. Now <span 
class="cmmi-12">expr </span>is uneffected, so you can get back to working
      on it armed with new ideas. </dd></dl>
<a 
 id="dx8-79001"></a>

<!--l. 1337--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.6.3   </span> <a 
 id="x8-800004.6.3"></a>SetCommutative[a, b, c, <span 
class="cmmi-12">&#x2026;</span>]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: SetCommutative[a, b, c, <span 
class="cmmi-12">&#x2026;</span>] sets all the symbols <span 
class="cmmi-12">a</span>, <span 
class="cmmi-12">b</span>, <span 
class="cmmi-12">c</span>, <span 
class="cmmi-12">&#x2026;</span> to be commutative.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: Symbols separated by commas
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: None </dd></dl>
<a 
 id="dx8-80001"></a>
<!--l. 1359--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.6.4   </span> <a 
 id="x8-810004.6.4"></a>SetCommutingOperators[b,c]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description:       SetCommutingOperators       takes       exactly       two       parameters.
      SetCommutingOperators[b, c] will implement the definitions which follow. They are in
      pseudo-code so that the meaning will not be obscured b ** c becomes c ** b if LeftQ[b,
      c]; and c ** b becomes b ** c if LeftQ[b, c]; ). See SetCommutingFunctions and LeftQ.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments:  <span 
class="cmmi-12">b</span>, <span 
class="cmmi-12">c </span>are symbols.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations:  <span 
class="cmbx-12">NOTE: </span>The above implementation will NOT lead to infinite
      loops.
      <br class="newline">
      <br class="newline">&#x00A0;<span 
class="cmbx-12">WARNING: </span>If one says SetCommutingOperators[b, c] and then sets only LeftQ[c,b],

      then neither of the above rules will be executed. Therefore, one must remember the
      order of the two parameters in the statement. One obvious helpful habit would be to
      use alphabetical order (i.e., say SetCommutingOperators[a,b] and not the reverse). </dd></dl>
<a 
 id="dx8-81001"></a>
<!--l. 1366--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.6.5   </span> <a 
 id="x8-820004.6.5"></a>LeftQ[expr]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: See SetCommutingFunctions and SetCommutingOperators.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">expr </span>is an algebraic expression.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: None </dd></dl>
<a 
 id="dx8-82001"></a>
<!--l. 1374--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.6.6   </span> <a 
 id="x8-830004.6.6"></a>CommutativeQ[X]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">CQ</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description:  <span 
class="cmmi-12">CommutativeQ</span>[<span 
class="cmmi-12">X</span>]  is  True  if  <span 
class="cmmi-12">X  </span>is  commutative,  and  False  if  <span 
class="cmmi-12">X  </span>is
      noncommutative.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">X </span>is a symbol.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: See the description of SetNonCommutative for the defaults. </dd></dl>

<a 
 id="dx8-83001"></a>
<!--l. 1382--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.6.7   </span> <a 
 id="x8-840004.6.7"></a>CommutativeAllQ[expr]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: CommutativeAllQ[expr] is True if <span 
class="cmmi-12">expr </span>does not have any non-commuting
      sub-expressions, and False otherwise.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">expr </span>is an algebraic expression.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: None </dd></dl>
<a 
 id="dx8-84001"></a>
<!--l. 1384--><p class="noindent">
   <h3 class="sectionHead"><span class="titlemark">4.7   </span> <a 
 id="x8-850004.7"></a>Operations on elements in an algebra</h3>
<!--l. 1393--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.7.1   </span> <a 
 id="x8-860004.7.1"></a>inv[x]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: Inverse &#8211; a ** inv[a]=inv[a] ** a=Id
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">x </span>is a symbol.

      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: Warning: NCAlgebra does not check that <span 
class="cmmi-12">inv</span>[<span 
class="cmmi-12">x</span>] exists or even
      that it makes sense (e.g. non-square matrices). This is the responsibility of the user. </dd></dl>
<a 
 id="dx8-86001"></a>
<!--l. 1401--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.7.2   </span> <a 
 id="x8-870004.7.2"></a>invL[x]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">invL</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: Left inverse &#8211; invL[a] ** a=Id
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">x </span>is a symbol
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: Warning. NCAlgebra does not check that <span 
class="cmmi-12">invL</span>[<span 
class="cmmi-12">x</span>] exists. This is
      the responsibility of the user. </dd></dl>
<a 
 id="dx8-87001"></a>
<!--l. 1409--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.7.3   </span> <a 
 id="x8-880004.7.3"></a>invR[x]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">invR</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: invR[x] is the right inverse &#8211; a ** invR[a]=Id
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">x </span>is a symbol

      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: Warning. NCAlgebra does not check that <span 
class="cmmi-12">invR</span>[<span 
class="cmmi-12">x</span>] exists. This is
      the responsibility of the user. </dd></dl>
<a 
 id="dx8-88001"></a>
<!--l. 1417--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.7.4   </span> <a 
 id="x8-890004.7.4"></a>invQ[x]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: invQ[m] = True forces <span 
class="cmmi-12">invR</span>[<span 
class="cmmi-12">m</span>] and <span 
class="cmmi-12">invL</span>[<span 
class="cmmi-12">m</span>] to be rewritten as <span 
class="cmmi-12">inv</span>[<span 
class="cmmi-12">m</span>]
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">x </span>is an expression.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: We never use this command. </dd></dl>
<a 
 id="dx8-89001"></a>
<!--l. 1428--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.7.5   </span> <a 
 id="x8-900004.7.5"></a>ExpandQ[inv]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: If <span 
class="cmmi-12">ExpandQ</span>[<span 
class="cmmi-12">inv</span>] is set to <span 
class="cmmi-12">True</span>, an inverse of a product will be expanded to
      a product of inverses. If it is set to <span 
class="cmmi-12">False</span>, then a product of inverses will be rewritten
      to be a inverse of a product.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: inv

      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: None </dd></dl>
<a 
 id="dx8-90001"></a>
<!--l. 1439--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.7.6   </span> <a 
 id="x8-910004.7.6"></a>ExpandQ[tp]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: If <span 
class="cmmi-12">ExpandQ</span>[<span 
class="cmmi-12">tp</span>] is set to <span 
class="cmmi-12">True</span>, a transpose of a product will be expanded to
      a product of transposes. If it is set to <span 
class="cmmi-12">False</span>, then a product of transposes will be
      rewritten to be a transpose of a product.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: tp
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: None </dd></dl>
<a 
 id="dx8-91001"></a>
<!--l. 1448--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.7.7   </span> <a 
 id="x8-920004.7.7"></a>OverrideInverse</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: <span 
class="cmmi-12">OverrideInverse </span>is a variable which is either <span 
class="cmmi-12">True </span>or <span 
class="cmmi-12">False</span>.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: If <span 
class="cmmi-12">OverrideInverse </span>is set to <span 
class="cmmi-12">True</span>, then the replacement of invL and invR by
      inv (when <span 
class="cmmi-12">x </span>is invertible) is suppressed even if invQ is <span 
class="cmmi-12">True</span>. The default is <span 
class="cmmi-12">False</span>.

      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: None </dd></dl>
<a 
 id="dx8-92001"></a>
<!--l. 1457--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.7.8   </span> <a 
 id="x8-930004.7.8"></a>aj[expr]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: <span 
class="cmmi-12">aj</span>[<span 
class="cmmi-12">expr</span>] takes the adjoint of the expression <span 
class="cmmi-12">expr</span>. Note that basic laws like
      <span 
class="cmmi-12">aj</span>[<span 
class="cmmi-12">a </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">b</span>] = <span 
class="cmmi-12">aj</span>[<span 
class="cmmi-12">b</span>] <span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">aj</span>[<span 
class="cmmi-12">a</span>] are automatically executed.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments:  <span 
class="cmmi-12">expr </span>is an algebraic expression
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations:  None </dd></dl>
<a 
 id="dx8-93001"></a>
<!--l. 1466--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.7.9   </span> <a 
 id="x8-940004.7.9"></a>tp[expr]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: <span 
class="cmmi-12">tp</span>[<span 
class="cmmi-12">expr</span>] takes the transpose of expression <span 
class="cmmi-12">expr</span>. Note that basic laws like
      <span 
class="cmmi-12">tp</span>[<span 
class="cmmi-12">a </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">b</span>] = <span 
class="cmmi-12">tp</span>[<span 
class="cmmi-12">b</span>] <span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">tp</span>[<span 
class="cmmi-12">a</span>] are automatically executed.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">expr </span>is an algebraic expression
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: None </dd></dl>

<a 
 id="dx8-94001"></a>
<!--l. 1475--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.7.10   </span> <a 
 id="x8-950004.7.10"></a>co[expr]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: <span 
class="cmmi-12">co</span>[<span 
class="cmmi-12">expr</span>] takes the complex conjugate of <span 
class="cmmi-12">expr</span>. Note basic laws like
      <br class="newline">co[a**b]=co[a]**co[b] and co[a]=aj[tp[a]]=tp[aj[a]]
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">expr </span>is an algebraic expression
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: None </dd></dl>
<a 
 id="dx8-95001"></a>
<!--l. 1477--><p class="noindent">
   <h3 class="sectionHead"><span class="titlemark">4.8   </span> <a 
 id="x8-960004.8"></a>Convexity of a NC function</h3>
<!--l. 1479--><p class="noindent">This chapter describes commands which do two things. One is compute the &#8221;region&#8221; on which a
noncommutative function is matrix convex. The other is take a noncommutative quadratic
function variables <span 
class="cmmi-12">H</span><sub ><span 
class="cmr-8">1</span></sub><span 
class="cmmi-12">,H</span><sub ><span 
class="cmr-8">2</span></sub><span 
class="cmmi-12">, </span>etc and give a Gram representation for it, that is, represent it
as
   <center class="math-display" >
<img 
src="NCBIGDOC29x.png" alt="     T
V [H]  M V [H]  " class="math-display" ></center> a
&#8221;vector&#8221; with the <span 
class="cmmi-12">H</span><sub ><span 
class="cmmi-8">j</span></sub> entering linearly and <span 
class="cmmi-12">M </span>a matrix. Other commands are described here but

they are subservient to <span 
class="cmbx-12">NCConvexityRegion[afunction,alist,options] </span>and would not be used
independently of it. The commands in this chapter are not listed alphabetically but are listed in
the presumed order of importance.
<!--l. 1606--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.8.1   </span> <a 
 id="x8-970004.8.1"></a>NCConvexityRegion[afunction,alistOfVars,opts]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None.</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description:  <span 
class="cmtt-12">NCConvexityRegion</span>[afunction,alistOfVars,opts]  computes  the  &#8221;region&#8221;  on
      which <span 
class="cmtt-12">afunction </span>is matrix convex with respect to <span 
class="cmtt-12">alistOfVars</span>. It performs three main
      operations. First it computes the Hessian with respect to <span 
class="cmti-12">alistOfVars </span>(see <span 
class="cmtt-12">NCHessian</span>).
      Then,  using  <span 
class="cmtt-12">NCMatrixOfQuadratic</span>,  the  Hessian  is  factored  into  the  form  <span 
class="cmmi-12">v</span><sup ><span 
class="cmmi-8">t</span></sup><span 
class="cmmi-12">Mv</span>.
      Finally,  depending  on  the  option  <span 
class="cmtt-12">AllPermutation</span>,  either  <span 
class="cmtt-12">NCAllPermutationLDU</span>
      or  <span 
class="cmtt-12">NCLDUDecomposition </span>is  called  to  compute  the  <span 
class="cmmi-12">LDU  </span>factorization  of  <span 
class="cmmi-12">M</span>,  the
      default being <span 
class="cmtt-12">AllPermutation </span><span 
class="cmsy-10x-x-120">&#x2192; </span><span 
class="cmtt-12">NCLDUDecomposition</span>. If <span 
class="cmmi-12">D </span>ends up being diagonal,
      then  a  list  of  the  diagonal  elements  of  <span 
class="cmmi-12">D  </span>is  returned.  If  <span 
class="cmmi-12">D  </span>ends  up  being
      block  diagonal  with  2 <span 
class="cmsy-10x-x-120">&#x00D7; </span>2  blocks,  then  a  message  is  printed  out  and  the  list:
      <span 
class="cmsy-10x-x-120">{{</span><span 
class="cmmi-12">diagonalentries</span><span 
class="cmsy-10x-x-120">}</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{</span><span 
class="cmmi-12">subdiagonalentries</span><span 
class="cmsy-10x-x-120">}</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{-</span><span 
class="cmmi-12">subdiagonalentries</span><span 
class="cmsy-10x-x-120">}} </span>is returned. The
      region of convexity of <span 
class="cmtt-12">afunction </span>with respect to <span 
class="cmtt-12">alistOfVars </span>equals the closure, in
      a certain sense, of the set of matrices which makes all <span 
class="cmtt-12">diagonal entries </span>positive.
      If there are non-zero <span 
class="cmtt-12">subdiagonal entries</span>, then <span 
class="cmtt-12">afunction </span>is typically not matrix
      convex  on  any  open  set.  Options  permit  the  user  to  select  a  range  of  different
      permutation matrices, thereby producing several possibly distinct diagonal matrices
      <span 
class="cmmi-12">D</span>.
      <br class="newline"><span 
class="cmbx-12">EXAMPLE: </span><span 
class="cmtt-12">NCConvexityRegion</span>[<span 
class="cmmi-12">x </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">y </span>+ <span 
class="cmmi-12">y </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x,</span><span 
class="cmsy-10x-x-120">{</span><span 
class="cmmi-12">x,y</span><span 
class="cmsy-10x-x-120">}</span>] gives:
      <br class="newline">&#x00A0;     L**D**tp[L] gave non-trivial blocks, so the output list is:
      <br class="newline">&#x00A0;     <span 
class="cmsy-10x-x-120">{{</span>diagonal<span 
class="cmsy-10x-x-120">}</span>,<span 
class="cmsy-10x-x-120">{</span>subdiagonal<span 
class="cmsy-10x-x-120">}</span>,<span 
class="cmsy-10x-x-120">{</span>-subdiagonal<span 
class="cmsy-10x-x-120">}}</span>
      <br class="newline">&#x00A0;     <span 
class="cmsy-10x-x-120">{{{</span>0<span 
class="cmmi-12">, </span>0<span 
class="cmsy-10x-x-120">}</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{</span>2<span 
class="cmsy-10x-x-120">}</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{-</span>2<span 
class="cmsy-10x-x-120">}}}</span>
      <br class="newline">While, <span 
class="cmtt-12">NCConvexityRegion</span>[<span 
class="cmmi-12">x </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">y </span>+ <span 
class="cmmi-12">y </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x,</span><span 
class="cmsy-10x-x-120">{</span><span 
class="cmmi-12">x,y</span><span 
class="cmsy-10x-x-120">}</span><span 
class="cmmi-12">,AllPermutation </span><span 
class="cmsy-10x-x-120">&#x2192; </span><span 
class="cmmi-12">True</span>] gives:
      <br class="newline">&#x00A0;     Middle matrix is size 2 X 2
      <br class="newline">&#x00A0;     At most 2 permutations possible.
      <br class="newline">&#x00A0;     <span 
class="cmsy-10x-x-120">{</span>1<span 
class="cmsy-10x-x-120">}</span>

      <br class="newline">&#x00A0;     L**D**tp[L] gave non-trivial blocks, so the output list is:
      <br class="newline">&#x00A0;     <span 
class="cmsy-10x-x-120">{{</span>diagonal<span 
class="cmsy-10x-x-120">}</span>,<span 
class="cmsy-10x-x-120">{</span>subdiagonal<span 
class="cmsy-10x-x-120">}</span>,<span 
class="cmsy-10x-x-120">{</span>-subdiagonal<span 
class="cmsy-10x-x-120">}}</span>
      <br class="newline">&#x00A0;     <span 
class="cmsy-10x-x-120">{{{</span>0<span 
class="cmmi-12">, </span>0<span 
class="cmsy-10x-x-120">}</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{</span>2<span 
class="cmsy-10x-x-120">}</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{-</span>2<span 
class="cmsy-10x-x-120">}}}</span>
      <br class="newline">&#x00A0;     In both cases, <span 
class="cmtt-12">NCHessian</span>[<span 
class="cmmi-12">x </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">y </span>+ <span 
class="cmmi-12">y </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x,</span><span 
class="cmsy-10x-x-120">{</span><span 
class="cmmi-12">x,h</span><span 
class="cmsy-10x-x-120">}</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{</span><span 
class="cmmi-12">y,k</span><span 
class="cmsy-10x-x-120">}</span>] gives
      <br class="newline">&#x00A0;     2<span 
class="cmmi-12">h </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">k </span>+ 2<span 
class="cmmi-12">k </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">h</span>,
      <br class="newline"><span 
class="cmtt-12">NCMatrixOfQuadratic</span>[2<span 
class="cmmi-12">h </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">k </span>+ 2<span 
class="cmmi-12">k </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">h,</span><span 
class="cmsy-10x-x-120">{</span><span 
class="cmmi-12">h,k</span><span 
class="cmsy-10x-x-120">}</span>] gives
      <br class="newline">&#x00A0;     <span 
class="cmsy-10x-x-120">{{{</span><span 
class="cmmi-12">h,k</span><span 
class="cmsy-10x-x-120">}}</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{{</span>0<span 
class="cmmi-12">, </span>2<span 
class="cmsy-10x-x-120">}</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{</span>2<span 
class="cmmi-12">, </span>0<span 
class="cmsy-10x-x-120">}}</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{{</span><span 
class="cmmi-12">h</span><span 
class="cmsy-10x-x-120">}</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{</span><span 
class="cmmi-12">k</span><span 
class="cmsy-10x-x-120">}}}</span>,
      <br class="newline">and depending on if <span 
class="cmtt-12">AllPermutation </span>is set to <span 
class="cmtt-12">True </span>or <span 
class="cmtt-12">False </span>you have that either
      <span 
class="cmtt-12">NCLDUDecomposition</span>[<span 
class="cmsy-10x-x-120">{{</span>0<span 
class="cmmi-12">, </span>2<span 
class="cmsy-10x-x-120">}</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{</span>2<span 
class="cmmi-12">, </span>0<span 
class="cmsy-10x-x-120">}}</span>] gives
      <br class="newline">&#x00A0;    <span 
class="cmsy-10x-x-120">{{{</span>1<span 
class="cmmi-12">, </span>0<span 
class="cmsy-10x-x-120">}</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{</span>0<span 
class="cmmi-12">, </span>1<span 
class="cmsy-10x-x-120">}}</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{{</span>0<span 
class="cmmi-12">, </span>2<span 
class="cmsy-10x-x-120">}</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{</span>2<span 
class="cmmi-12">, </span>0<span 
class="cmsy-10x-x-120">}}</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{{</span>1<span 
class="cmmi-12">, </span>0<span 
class="cmsy-10x-x-120">}</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{</span>0<span 
class="cmmi-12">, </span>1<span 
class="cmsy-10x-x-120">}}</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{{</span>1<span 
class="cmmi-12">, </span>0<span 
class="cmsy-10x-x-120">}</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{</span>0<span 
class="cmmi-12">, </span>1<span 
class="cmsy-10x-x-120">}}}</span>
      <br class="newline">or <span 
class="cmtt-12">NCAllPermutationLDU</span>[<span 
class="cmsy-10x-x-120">{{</span>0<span 
class="cmmi-12">, </span>2<span 
class="cmsy-10x-x-120">}</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{</span>2<span 
class="cmmi-12">, </span>0<span 
class="cmsy-10x-x-120">}}</span>] gives
      <br class="newline">&#x00A0;    <span 
class="cmsy-10x-x-120">{{{{</span>1<span 
class="cmmi-12">, </span>0<span 
class="cmsy-10x-x-120">}</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{</span>0<span 
class="cmmi-12">, </span>1<span 
class="cmsy-10x-x-120">}}</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{{</span>0<span 
class="cmmi-12">, </span>2<span 
class="cmsy-10x-x-120">}</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{</span>2<span 
class="cmmi-12">, </span>0<span 
class="cmsy-10x-x-120">}}</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{{</span>1<span 
class="cmmi-12">, </span>0<span 
class="cmsy-10x-x-120">}</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{</span>0<span 
class="cmmi-12">, </span>1<span 
class="cmsy-10x-x-120">}}</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{{</span>1<span 
class="cmmi-12">, </span>0<span 
class="cmsy-10x-x-120">}</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{</span>0<span 
class="cmmi-12">, </span>1<span 
class="cmsy-10x-x-120">}}}</span><span 
class="cmmi-12">,</span>
      <br class="newline">&#x00A0;    <span 
class="cmsy-10x-x-120">{{{</span>1<span 
class="cmmi-12">, </span>0<span 
class="cmsy-10x-x-120">}</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{</span>0<span 
class="cmmi-12">, </span>1<span 
class="cmsy-10x-x-120">}}</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{{</span>0<span 
class="cmmi-12">, </span>2<span 
class="cmsy-10x-x-120">}</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{</span>2<span 
class="cmmi-12">, </span>0<span 
class="cmsy-10x-x-120">}}</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{{</span>1<span 
class="cmmi-12">, </span>0<span 
class="cmsy-10x-x-120">}</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{</span>0<span 
class="cmmi-12">, </span>1<span 
class="cmsy-10x-x-120">}}</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{{</span>1<span 
class="cmmi-12">, </span>0<span 
class="cmsy-10x-x-120">}</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{</span>0<span 
class="cmmi-12">, </span>1<span 
class="cmsy-10x-x-120">}}}}</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments:  <span 
class="cmmi-12">afunction </span>is  a  function  whose  variables  are  listed  in  <span 
class="cmmi-12">alistOfV ars</span>,  where
      <span 
class="cmmi-12">alistOfV ars </span>should be of the form <span 
class="cmsy-10x-x-120">{</span><span 
class="cmmi-12">x</span><sub ><span 
class="cmr-8">1</span></sub><span 
class="cmmi-12">,x</span><sub ><span 
class="cmr-8">2</span></sub><span 
class="cmmi-12">,</span><span 
class="cmmi-12">&#x2026;</span><span 
class="cmmi-12">,x</span><sub ><span 
class="cmmi-8">n</span></sub><span 
class="cmsy-10x-x-120">}</span><span 
class="cmmi-12">.</span>
      <br class="newline">The default options for <span 
class="cmtt-12">NCConvexityRegion </span>are:
      <br class="newline">&#x00A0;    <span 
class="cmtt-12">NCSimplifyDiagonal </span><span 
class="cmsy-10x-x-120">&#x2192;</span><span 
class="cmtt-12">False</span>
      <br class="newline">&#x00A0;    <span 
class="cmtt-12">DiagonalSelection </span><span 
class="cmsy-10x-x-120">&#x2192; </span><span 
class="cmtt-12">False</span>
      <br class="newline">&#x00A0;    <span 
class="cmtt-12">ReturnPermutation </span><span 
class="cmsy-10x-x-120">&#x2192; </span><span 
class="cmtt-12">False</span>
      <br class="newline">&#x00A0;    <span 
class="cmtt-12">ReturnBorderVector </span><span 
class="cmsy-10x-x-120">&#x2192; </span><span 
class="cmtt-12">False</span>
      <br class="newline">&#x00A0;    <span 
class="cmtt-12">AllPermutation </span><span 
class="cmsy-10x-x-120">&#x2192; </span><span 
class="cmtt-12">False</span>
      <br class="newline">&#x00A0;    <span 
class="cmtt-12">NCSimplifyDiagonal </span>is an option geared toward a similar option used in
      <br class="newline"><span 
class="cmtt-12">NCLDUDecomposition</span>. This will make sure that the pivots (or diagonal entries) are
      all first simplified with <span 
class="cmtt-12">NCSimplifyRational </span>before they are used to check that the
      pivots are all nonzero. Simplifying the pivots using <span 
class="cmtt-12">NCSimplifyRational </span>can be quite
      time consuming, so by default we commute everything and then use Mathematica
      simplification commmands. We do this only to convince ourselves that the pivot is
      nonzero. If all the pivots are zero using <span 
class="cmtt-12">CommuteEverything </span>we then revert to using
      <span 
class="cmtt-12">NCSimplifyRational </span>to verify our suspicions. Setting <span 
class="cmtt-12">NCSimplifyDiagonal </span><span 
class="cmsy-10x-x-120">&#x2192; </span><span 
class="cmtt-12">True</span>
      will bypass the commute everything step. (Note: Either way, the unsimplified form of
      the pivot is returned unless it is equal to zero.)
      <br class="newline">&#x00A0;    The option <span 
class="cmtt-12">AllPermutation </span>tells <span 
class="cmtt-12">NCConvexityRegion </span>which of
      <br class="newline"><span 
class="cmtt-12">NCLDUDecomposition </span>or <span 
class="cmtt-12">NCAllPermutationLDU </span>to use. Setting <span 
class="cmtt-12">AllPermutation </span>to
      <span 
class="cmtt-12">True </span>will use
      <br class="newline"><span 
class="cmtt-12">NCAllPermutationLDU</span>,while <span 
class="cmtt-12">False </span>uses <span 
class="cmtt-12">NCLDUDecomposition</span>. The default value is

      <span 
class="cmtt-12">AllPermutation </span><span 
class="cmsy-10x-x-120">&#x2192; </span><span 
class="cmtt-12">False</span>. The following pertains to the case where <span 
class="cmtt-12">AllPermutation</span>
      is set to <span 
class="cmtt-12">True</span>. If you decide to do this, then you should also set <span 
class="cmtt-12">DiagonalSelection</span>
      to  the  permutations  you  would  like  <span 
class="cmtt-12">NCAllPermutationLDU </span>to  use.  Since  different
      permutations return different diagonals, some diagonals are simpler to work with than
      others. On the other hand, if <span 
class="cmtt-12">AllPermutation </span>is set to <span 
class="cmtt-12">False</span>, which it defaults to,
      then <span 
class="cmtt-12">NCConvexityRegion </span>calls <span 
class="cmtt-12">NCLDUDecomposition </span>and what follows does not apply
      as no permutations are used. Different permutations return different diagonals. Some
      diagonals are simpler to work with than others. Because of this, we allow the user to
      select a sampling of different permutations. The total number of permutations will not
      be known until <span 
class="cmmi-12">M </span>is computed. After <span 
class="cmmi-12">M </span>is computed, the total number of possible
      permutations will be printed on the screen. <span 
class="cmtt-12">DiagonalSelection </span><span 
class="cmsy-10x-x-120">&#x2192; {</span><span 
class="cmmi-12">n</span><span 
class="cmsy-10x-x-120">} </span>returns the
      diagonals resulting from the first <span 
class="cmmi-12">n </span>permutations. <span 
class="cmtt-12">DiagonalSelection</span><span 
class="cmsy-10x-x-120">&#x2192;{</span><span 
class="cmmi-12">k</span>,<span 
class="cmmi-12">n</span><span 
class="cmsy-10x-x-120">} </span>returns
      the diagonals resulting from the <span 
class="cmmi-12">k</span><sup ><span 
class="cmmi-8">th</span></sup> through <span 
class="cmmi-12">n</span><sup ><span 
class="cmmi-8">th</span></sup> permutations. Since the total number
      of permutations is assumed to be unknown by the user, if <span 
class="cmmi-12">n </span>is too high, then <span 
class="cmmi-12">n </span>is
      replaced by the total number of permutations. Also, not all of the permutations are
      permissible. Because of this, <span 
class="cmtt-12">NCLDUDecomposition </span>automatically pivots if an invalid
      permutation is used for a particular step. This means it is possible that not all the
      diagonals returned result from different permutations. For this reason there is the
      option <span 
class="cmtt-12">ReturnPermutation </span>which if entered as <span 
class="cmtt-12">True </span>returns the permutations used
      for  each  resulting  factorization.  Finally,  the  user  may  wish  to  analyze  the  border
      vectors  and  may  do  so  by  setting  <span 
class="cmtt-12">ReturnBorderVector </span>to  <span 
class="cmtt-12">True</span>.  This  will  cause
      <span 
class="cmtt-12">NCConvexityRegion </span>to return the border vectors <span 
class="cmmi-12">v </span>from the <span 
class="cmmi-12">v</span><sup ><span 
class="cmmi-8">t</span></sup><span 
class="cmmi-12">Mv </span>factorization of the
      hessian. Now <span 
class="cmmi-12">v</span><sup ><span 
class="cmmi-8">t</span></sup> will have the form
      <center class="math-display" >
      <img 
src="NCBIGDOC30x.png" alt="L11H1, L12H1, &#x22C5;&#x22C5;&#x22C5; ,L1k1H1, &#x22C5;&#x22C5;&#x22C5;Ln1Hn, Ln2Hn, &#x22C5;&#x22C5;&#x22C5; ,LnknHn
      " class="math-display" ></center> So what will actually be returned is a list of the form

      <center class="math-display" >
      <img 
src="NCBIGDOC31x.png" alt="{{L11,...,L1k1}, ...,{Ln1,...,Lnkn}}.
      " class="math-display" ></center> This vector will be formed using a call to <span 
class="cmtt-12">NCBorderVectorGather</span>. Also, a call will be
      made to <span 
class="cmtt-12">NCIndependenceCheck </span>to determine, if possible, whether or not the elements
      of the above list are independent. The results of this check will be printed to the screen.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: None. </dd></dl>
<a 
 id="dx8-97001"></a>
<!--l. 1736--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.8.2   </span> <a 
 id="x8-980004.8.2"></a>NCMatrixOfQuadratic[ <span 
class="cmsy-10x-x-120"><img 
src="cmsy10-c-51.png" alt="Q" class="10-120x-x-51" /></span>, <span 
class="cmsy-10x-x-120">{</span><span 
class="cmmi-12">H</span><sub ><span 
class="cmr-8">1</span></sub><span 
class="cmmi-12">,</span><span 
class="cmmi-12">&#x2026;</span><span 
class="cmmi-12">,H</span><sub ><span 
class="cmmi-8">n</span></sub><span 
class="cmsy-10x-x-120">} </span>] </h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None.</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description:                 <span 
class="cmtt-12">NCMatrixOfQuadratic[ </span><span 
class="cmsy-10x-x-120"><img 
src="cmsy10-c-51.png" alt="Q" class="10-120x-x-51" /></span><span 
class="cmmi-12">, </span><span 
class="cmsy-10x-x-120">{</span><span 
class="cmmi-12">H</span><sub ><span 
class="cmr-8">1</span></sub><span 
class="cmmi-12">,H</span><sub ><span 
class="cmr-8">2</span></sub><span 
class="cmmi-12">,</span><span 
class="cmmi-12">&#x2026;</span><span 
class="cmmi-12">,H</span><sub ><span 
class="cmmi-8">n</span></sub><span 
class="cmsy-10x-x-120">} </span><span 
class="cmtt-12">]           </span>gives
      a vector matrix factorization of a symmetric quadratic function <span 
class="cmsy-10x-x-120"><img 
src="cmsy10-c-51.png" alt="Q" class="10-120x-x-51" /> </span>in noncommutative
      variables <img 
src="NCBIGDOC32x.png" alt="H&#x20D7;"  class="vec" > = <span 
class="cmsy-10x-x-120">{</span><span 
class="cmmi-12">H</span><sub ><span 
class="cmr-8">1</span></sub><span 
class="cmmi-12">,H</span><sub ><span 
class="cmr-8">2</span></sub><span 
class="cmmi-12">,</span><span 
class="cmmi-12">&#x2026;</span><span 
class="cmmi-12">,H</span><sub ><span 
class="cmmi-8">n</span></sub><span 
class="cmsy-10x-x-120">} </span>and their transposes.
      <br class="newline"><span 
class="cmtt-12">NCMatrixOfQuadratic</span>[  <span 
class="cmsy-10x-x-120"><img 
src="cmsy10-c-51.png" alt="Q" class="10-120x-x-51" /></span>,  <span 
class="cmsy-10x-x-120">{</span><span 
class="cmmi-12">H</span><sub ><span 
class="cmr-8">1</span></sub><span 
class="cmmi-12">,H</span><sub ><span 
class="cmr-8">2</span></sub><span 
class="cmmi-12">,</span><span 
class="cmmi-12">&#x2026;</span><span 
class="cmmi-12">,H</span><sub ><span 
class="cmmi-8">n</span></sub><span 
class="cmsy-10x-x-120">} </span>],  generates  the  list  <span 
class="cmsy-10x-x-120">{</span><span 
class="cmtt-12">left border</span>
      <span 
class="cmtt-12">vector, coefficient matrix, right border vector</span><span 
class="cmsy-10x-x-120">}</span>. That is, <span 
class="cmmi-12">Q </span>is factored into
      the vector-matrix-vector product <span 
class="cmmi-12">V </span>[<img 
src="NCBIGDOC33x.png" alt=" &#x20D7;
H"  class="vec" >]<sup ><span 
class="cmmi-8">T</span> </sup><span 
class="cmmi-12">M</span><sub >
      <!--l. 1736--><p class="noindent"></sub>Q V[<img 
src="NCBIGDOC34x.png" alt="H "  class="vec" >]<span 
class="cmmi-12">.Thevector</span>V[<img 
src="NCBIGDOC35x.png" alt="H "  class="vec" >]<span 
class="cmmi-12">islinearin</span><img 
src="NCBIGDOC36x.png" alt="H "  class="vec" ><span 
class="cmmi-12">andiscalleda</span><span 
class="cmmi-12">bordervectorofthequadraticfunction</span>Q<span 
class="cmmi-12">.Thematrix</span>M&#x02D9;Q<span 
class="cmmi-12">iscalledthe</span><span 
class="cmmi-12">coefficientmatrixofthequadraticfunction</span>Q<span 
class="cmmi-12">.</span><span 
class="cmmi-12">Arguments </span>:<span 
class="cmmi-12">Eachtermof</span>Q<span 
class="cmmi-12">isassumedtobeaquadraticexpressionintermsofthevariables</span>H&#x02D9;1,H&#x02D9;2,. . . ,H&#x02D9;n<span 
class="cmmi-12">andtheirtransposes</span>(Q<span 
class="cmmi-12">ishomogeneous</span>)<span 
class="cmmi-12">.</span>
      <span 
class="cmmi-12">Forexample,supposethat</span>Q=3 tp[x]**y+3 tp[y]**x<span 
class="cmmi-12">andthat</span>
      <img 
src="NCBIGDOC37x.png" alt="H "  class="vec" > = <span 
class="cmsy-10x-x-120">{</span>x,y<span 
class="cmsy-10x-x-120">}</span><span 
class="cmmi-12">.Then,</span><span 
class="cmmi-12">NCMatrixOfQuadratic</span>[Q<span 
class="cmmi-12">,</span><img 
src="NCBIGDOC38x.png" alt="H "  class="vec" >]<span 
class="cmmi-12">gives</span><span 
class="cmsy-10x-x-120">{{{</span><span 
class="cmmi-12">tp</span>[<span 
class="cmmi-12">x</span>]<span 
class="cmmi-12">,tp</span>[<span 
class="cmmi-12">y</span>]<span 
class="cmsy-10x-x-120">}}</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{{</span>0<span 
class="cmmi-12">, </span>3<span 
class="cmsy-10x-x-120">}</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{</span>3<span 
class="cmmi-12">, </span>0<span 
class="cmsy-10x-x-120">}}</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{{</span><span 
class="cmmi-12">x</span><span 
class="cmsy-10x-x-120">}</span><span 
class="cmmi-12">,</span><span 
class="cmsy-10x-x-120">{</span><span 
class="cmmi-12">y</span><span 
class="cmsy-10x-x-120">}}}</span><span 
class="cmmi-12">.In</span><span 
class="cmmi-12">MatrixForm</span><span 
class="cmmi-12">,thislookslike</span><img 
src="NCBIGDOC39x.png" alt="                                 (tp[x]  tp[y])"  class="left" align="middle"><span 
class="cmsy-10x-x-120">*</span>
      <img 
src="NCBIGDOC40x.png" alt="(       )
   0  3
   3  0"  class="left" align="middle"><span 
class="cmsy-10x-x-120">*</span><img 
src="NCBIGDOC41x.png" alt="(    )
   x
   y"  class="left" align="middle"><span 
class="cmmi-12">.</span>
      <span 
class="cmmi-12">Ingeneral,suppose</span>Q<span 
class="cmmi-12">isaquadraticfunctionoftwovariables,</span><img 
src="NCBIGDOC42x.png" alt="H "  class="vec" > = <span 
class="cmsy-10x-x-120">{</span>H,K<span 
class="cmsy-10x-x-120">}</span><span 
class="cmmi-12">,withalltransposeelements</span>H&#x02C6;T, K&#x02C6;T<span 
class="cmmi-12">occuringbeforeallnon</span><span 
class="cmsy-10x-x-120">-</span>
      <span 
class="cmmi-12">transposeelements.Then</span><span 
class="cmmi-12">NCMatrixOfQuadratic</span><span 
class="cmmi-12">willreturnthe</span><span 
class="cmmi-12">leftbordervector</span>V[<img 
src="NCBIGDOC43x.png" alt="H "  class="vec" >]&#x02C6;T<span 
class="cmmi-12">,thematrix</span>M&#x02D9;Q<span 
class="cmmi-12">,andthe</span><span 
class="cmmi-12">rightvector</span>V[<img 
src="NCBIGDOC44x.png" alt="                              H
      "  class="vec" >]<span 
class="cmmi-12">where</span>
      <span 
class="cmmi-12">M</span><sub >
<!--l. 1736--><p class="noindent"></sub>Q                                                                                                                  :=

<img 
src="NCBIGDOC45x.png" alt="(                                                         )
     A11     A12    &#x22C5;&#x22C5;&#x22C5;   A1,&#x2113;1     A1,&#x2113;1+1   &#x22C5;&#x22C5;&#x22C5;    A1,n
||    AT12     A22    &#x22C5;&#x22C5;&#x22C5;   A2,&#x2113;1     A2,&#x2113;1+1   &#x22C5;&#x22C5;&#x22C5;    A2,n  ||
|    &#x22C5;&#x22C5;&#x22C5;     &#x22C5;&#x22C5;&#x22C5;    &#x22C5;&#x22C5;&#x22C5;    &#x22C5;&#x22C5;&#x22C5;       &#x22C5;&#x22C5;&#x22C5;     &#x22C5;&#x22C5;&#x22C5;    &#x22C5;&#x22C5;&#x22C5;   |
||   AT       AT     &#x22C5;&#x22C5;&#x22C5;   A        A         &#x22C5;&#x22C5;&#x22C5;   A      ||
||    T1,&#x2113;1    T2,&#x2113;1          T&#x2113;1,&#x2113;1      &#x2113;1,&#x2113;1+1           &#x2113;1,n  ||
|  A 1,&#x2113;1+1  A2,&#x2113;1+1  &#x22C5;&#x22C5;&#x22C5;  A &#x2113;1,&#x2113;1+1  A &#x2113;1+1,&#x2113;1+1  &#x22C5;&#x22C5;&#x22C5;  A &#x2113;1+1,n |
(    &#x22C5;&#x22C5;&#x22C5;     &#x22C5;&#x22C5;&#x22C5;    &#x22C5;&#x22C5;&#x22C5;    &#x22C5;&#x22C5;&#x22C5;       &#x22C5;&#x22C5;&#x22C5;     &#x22C5;&#x22C5;&#x22C5;    &#x22C5;&#x22C5;&#x22C5;   )
    AT1,n     AT2,n   &#x22C5;&#x22C5;&#x22C5;   AT&#x2113;,n    AT&#x2113; +1,n   &#x22C5;&#x22C5;&#x22C5;    An,n
                             1        1"  class="left" align="middle"> and <span 
class="cmmi-12">V </span>[ <span 
class="cmmi-12">&#x20D7;</span><span 
class="cmmi-12">H</span>] := <span 
class="cmex-10x-x-120">(</span> 
<span 
class="cmex-10x-x-120">|</span> <span 
class="cmex-10x-x-120">|</span> 
<span 
class="cmex-10x-x-120">|</span> <span 
class="cmex-10x-x-120">|</span> 
<span 
class="cmex-10x-x-120">|</span> <span 
class="cmex-10x-x-120">|</span> 
<span 
class="cmex-10x-x-120">|</span> <span 
class="cmex-10x-x-120">|</span> 
<span 
class="cmex-10x-x-120">(</span> <span 
class="cmmi-12">HL</span><span 
class="cmr-8">1</span>
<span 
class="cmr-8">1</span>
       <span 
class="cmmi-12">HL</span><span 
class="cmr-8">1</span>
<span 
class="cmr-8">2</span>
         <span 
class="cmsy-10x-x-120">&#x22C5;&#x22C5;&#x22C5;</span>
  <span 
class="cmmi-12">HL</span><span 
class="cmr-8">1</span>
<span 
class="cmmi-8">&#x2113;</span><span 
class="cmr-6">1</span>
        <span 
class="cmmi-12">KL</span><span 
class="cmr-8">2</span>
<span 
class="cmr-8">1</span>
         <span 
class="cmsy-10x-x-120">&#x22C5;&#x22C5;&#x22C5;</span>
  <span 
class="cmmi-12">KL</span><span 
class="cmr-8">2</span>
<span 
class="cmmi-8">&#x2113;</span><span 
class="cmr-6">2</span>  <span 
class="cmex-10x-x-120">)</span>
      <span 
class="cmex-10x-x-120">|</span> <span 
class="cmex-10x-x-120">|</span>
      <span 
class="cmex-10x-x-120">|</span> <span 
class="cmex-10x-x-120">|</span>
      <span 
class="cmex-10x-x-120">|</span> <span 
class="cmex-10x-x-120">|</span>
      <span 
class="cmex-10x-x-120">|</span> <span 
class="cmex-10x-x-120">|</span>
      <span 
class="cmex-10x-x-120">)</span>
<span 
class="cmmi-12">forsome</span>L&#x02D9;i&#x02C6;j  ,  i=1,. . . ,<span 
class="cmmi-12">&#x2113;</span><span 
class="cmmi-8">j</span>. The <span 
class="cmmi-12">L</span><span 
class="cmmi-8">j</span>
<span 
class="cmmi-8">i</span> <span 
class="cmmi-12">, i </span>= 1<span 
class="cmmi-12">,</span><span 
class="cmmi-12">...</span><span 
class="cmmi-12">,&#x2113;</span><span 
class="cmmi-8">j</span>  are called the <span 
class="cmti-12">coefficients of the border</span>
<span 
class="cmti-12">vector</span>. The <span 
class="cmmi-12">L</span><span 
class="cmr-8">1</span>
<span 
class="cmmi-8">i</span>  corresponding to <span 
class="cmmi-12">H </span>are distinct and only one may be the identity matrix
(equivalently for the <span 
class="cmmi-12">L</span><span 
class="cmr-8">2</span>
<span 
class="cmmi-8">i</span>  corresponding to <span 
class="cmmi-12">K</span>). The border vector <span 
class="cmmi-12">V </span>is the vector composed
of <span 
class="cmmi-12">H</span>, <span 
class="cmmi-12">K </span>and <span 
class="cmmi-12">L</span><span 
class="cmmi-8">j</span>
<span 
class="cmmi-8">i</span>. The matrix <span 
class="cmmi-12">M</span><span 
class="cmsy-8"><img 
src="cmsy8-51.png" alt="Q" class="8x-x-51" /></span> is the matrix with <span 
class="cmmi-12">A</span><span 
class="cmmi-8">i,j</span> entries.
Noncommutative quadratics which are <span 
class="cmti-12">not hereditary </span>have a similar representation (which
takes more space to write) for such a quadratic in <span 
class="cmmi-12">H,K</span>. For example, the border vector for
a quadratic in <span 
class="cmmi-12">H</span>, <span 
class="cmmi-12">H</span><span 
class="cmmi-8">T</span> , <span 
class="cmmi-12">K</span>, <span 
class="cmmi-12">K</span><span 
class="cmmi-8">T</span>  has the form
                                   <span 
class="cmmi-10x-x-109">V </span><span 
class="cmr-10x-x-109">[</span><span 
class="cmmi-10x-x-109">H,K</span><span 
class="cmr-10x-x-109">] =</span> <span 
class="cmex-10x-x-109">[</span>
  <span 
class="cmmi-10x-x-109">V</span><span 
class="cmr-8">1</span>    <span 
class="cmmi-10x-x-109">V</span><span 
class="cmr-8">2</span>  <span 
class="cmex-10x-x-109">]</span>
<span 
class="cmr-10x-x-109">where we have</span>
                  <span 
class="cmmi-10x-x-109">V</span><span 
class="cmr-8">1</span> <span 
class="cmr-10x-x-109">=</span> <span 
class="cmex-10x-x-109">(</span>
 <span 
class="cmr-10x-x-109">(</span><span 
class="cmmi-10x-x-109">L</span><span 
class="cmr-8">1</span>
<span 
class="cmr-8">1</span><span 
class="cmr-10x-x-109">)</span><span 
class="cmmi-8">T</span> <span 
class="cmmi-10x-x-109">H</span><span 
class="cmmi-8">T</span> <span 
class="cmmi-10x-x-109">,</span><span 
class="cmsy-10x-x-109">&#x22C5;&#x22C5;&#x22C5;</span> <span 
class="cmmi-10x-x-109">,</span><span 
class="cmr-10x-x-109">(</span><span 
class="cmmi-10x-x-109">L</span><span 
class="cmr-8">1</span>
<span 
class="cmmi-8">&#x2113;</span><span 
class="cmr-6">1</span><span 
class="cmr-10x-x-109">)</span><span 
class="cmmi-8">T</span> <span 
class="cmmi-10x-x-109">H</span><span 
class="cmmi-8">T</span> <span 
class="cmmi-10x-x-109">,</span><span 
class="cmr-10x-x-109">(</span><span 
class="cmmi-10x-x-109">L</span><span 
class="cmr-8">2</span>
<span 
class="cmr-8">1</span><span 
class="cmr-10x-x-109">)</span><span 
class="cmmi-8">T</span> <span 
class="cmmi-10x-x-109">K</span><span 
class="cmmi-8">T</span> <span 
class="cmmi-10x-x-109">,</span><span 
class="cmsy-10x-x-109">&#x22C5;&#x22C5;&#x22C5;</span> <span 
class="cmmi-10x-x-109">,L</span><span 
class="cmr-10x-x-109">(</span><span 
class="cmr-8">2</span>
<span 
class="cmmi-8">&#x2113;</span><span 
class="cmr-6">2</span><span 
class="cmr-10x-x-109">)</span><span 
class="cmmi-8">T</span> <span 
class="cmmi-10x-x-109">K</span><span 
class="cmmi-8">T</span> <span 
class="cmex-10x-x-109">)</span>
<span 
class="cmr-10x-x-109">and</span>
                           <span 
class="cmmi-10x-x-109">V</span><span 
class="cmr-8">2</span> <span 
class="cmr-10x-x-109">=</span> <span 
class="cmex-10x-x-109">(</span><span 
class="cmr-10x-x-109">~</span>
  <span 
class="cmmi-10x-x-109">L</span><span 
class="cmr-8">1</span>
<span 
class="cmr-8">1</span><span 
class="cmmi-10x-x-109">H,</span><span 
class="cmsy-10x-x-109">&#x22C5;&#x22C5;&#x22C5;</span> <span 
class="cmmi-10x-x-109">,</span> <span 
class="cmr-10x-x-109">~</span> <span 
class="cmmi-10x-x-109">L</span><span 
class="cmr-8">1</span>
<span 
class="cmmi-8">&#x2113;</span><span 
class="cmr-6">1</span><span 
class="cmmi-10x-x-109">H,</span> <span 
class="cmr-10x-x-109">~</span> <span 
class="cmmi-10x-x-109">L</span><span 
class="cmr-8">2</span>
<span 
class="cmr-8">1</span><span 
class="cmmi-10x-x-109">K,</span><span 
class="cmsy-10x-x-109">&#x22C5;&#x22C5;&#x22C5;</span> <span 
class="cmmi-10x-x-109">,</span> <span 
class="cmr-10x-x-109">~</span> <span 
class="cmmi-10x-x-109">L</span><span 
class="cmr-8">2</span>
<span 
class="cmmi-8">&#x2113;</span><span 
class="cmr-6">2</span><span 
class="cmmi-10x-x-109">K</span><span 
class="cmex-10x-x-109">)</span>
 <span 
class="cmmi-10x-x-109">.</span>
We should emphasize that the size of the <span 
class="cmmi-12">M</span><span 
class="cmsy-8"><img 
src="cmsy8-51.png" alt="Q" class="8x-x-51" /></span> representation of a noncommutative quadratic
functions <span 
class="cmsy-10x-x-120"><img 
src="cmsy10-c-51.png" alt="Q" class="10-120x-x-51" /></span>[<span 
class="cmmi-12">H</span><span 
class="cmr-8">1</span><span 
class="cmmi-12">,</span><span 
class="cmmi-12">...</span><span 
class="cmmi-12">,H</span><span 
class="cmmi-8">k</span>] depends on the particular quadratic and not only on the number of
arguments of the quadratic. There are noncommutative quadratic functions in one variable
which have a representation with <span 
class="cmmi-12">M</span><span 
class="cmsy-8"><img 
src="cmsy8-51.png" alt="Q" class="8x-x-51" /></span> a 102 <span 
class="cmsy-10x-x-120">&#x00D7; </span>102 matrix.
The basic idea of <span 
class="cmtt-12">NCMatrixOfQuadratic </span>is that it searches for terms of form
                           <span 
class="cmmi-12">Left </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">X </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">Middle </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">Y </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">Right</span>
where <span 
class="cmmi-12">X </span>= <span 
class="cmmi-12">H</span><span 
class="cmmi-8">i</span> or <span 
class="cmmi-12">H</span><span 
class="cmmi-8">T</span>
<span 
class="cmmi-8">i</span>  and <span 
class="cmmi-12">Y </span>= <span 
class="cmmi-12">H</span><span 
class="cmmi-8">j</span> or <span 
class="cmmi-12">H</span><span 
class="cmmi-8">T</span>
<span 
class="cmmi-8">j</span>  for 1 <span 
class="cmsy-10x-x-120">&#x2264; </span>(<span 
class="cmmi-12">i,j</span>) <span 
class="cmsy-10x-x-120">&#x2264; </span><span 
class="cmmi-12">n</span>. Terms of the form <span 
class="cmmi-12">Left</span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">X </span>and
<span 
class="cmmi-12">Y </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">Right </span>are used to form the left and right vectors. Each time the search finds a unique
<span 
class="cmmi-12">Right </span>(<span 
class="cmmi-12">Left</span>) term causes the length of the right (left) border vector to be increased by one.
The term <span 
class="cmmi-12">Middle </span>becomes the entries in the matrix <span 
class="cmmi-12">M</span><span 
class="cmsy-8"><img 
src="cmsy8-51.png" alt="Q" class="8x-x-51" /></span>.
Comments / Limitations:  <span 
class="cmtt-12">NCMatrixOfQuadratic </span>will try to symmetrize the resulting matrix <span 
class="cmmi-12">M</span><span 
class="cmsy-8"><img 
src="cmsy8-51.png" alt="Q" class="8x-x-51" /></span>.
If  <span 
class="cmtt-12">NCMatrixOfQuadratic </span>is  unable  to  do  this,  an  error  message  will  be  printed  and  <span 
class="cmsy-10x-x-120">{</span>
<span 
class="cmtt-12">leftvector, matrix, rightvector </span><span 
class="cmsy-10x-x-120">} </span>will be returned, where <span 
class="cmtt-12">matrix </span>is not symmetric
and <span 
class="cmtt-12">leftvector </span>is not necessarily the transpose of <span 
class="cmtt-12">rightvector</span>. The vector-matrix-vector
product should still be equal to the orginal quadratic expression.

<a 
 id="dx8-98001"></a>
<!--l. 1810--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.8.3   </span> <a 
 id="x8-990004.8.3"></a>NCIndependenceCheck[aListofLists,variable]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None.</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description:   <span 
class="cmtt-12">NCIndependenceCheck[aListofLists,variable]  </span>is   aimed   at   verifying
      whether or not a given set of polynomials are independent or not. It analyzes each list
      of polynomials in <span 
class="cmti-12">aListofLists </span>separately. There are three possible types of outputs for
      each list in <span 
class="cmti-12">aListofLists</span>. Two of them correspond to <span 
class="cmtt-12">NCIndependenceCheck </span>successfully
      determining whether or not the list of polynomials is independent. The third type
      of  output  corresponds  to  an  unsuccessful  attempt  at  determining  dependence  or
      independence.  If  a  particular  list  is  determined  to  be  independent,  <span 
class="cmti-12">True  </span>will  be
      returned. If a list is determined to be dependent, a list beginning with <span 
class="cmti-12">False </span>containing
      a  set  of  coefficients  which  demonstrate  independence  will  be  returned.  Finally,  if
      <span 
class="cmtt-12">NCIndependenceCheck </span>cannot determine dependence or independence, it returns a list
      beginning with <span 
class="cmti-12">Undetermined </span>containing other information which is illustrated below
      and described further in Comments/Limitations.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmti-12">aListofLists </span>is a list containing a list of the polynomials which are suspected of being
      dependent. The argument <span 
class="cmti-12">variable </span>will be subscripted and used to return the coefficient
      dependencies for each list. Below is an example of a list of four lists. The first two are
      dependent, the third is independent, and the fourth is undetermined.
      <br class="newline">
      <br class="newline">Suppose you have four lists: <div class="eqnarray">
      <center class="math-display" >
      <img 
src="NCBIGDOC46x.png" alt="                       2              2   2    2 2
List1   =  {7, 6a,a,abd ,d,b,12a, d,4a d,a ,5a  ,b,b}
List2   =  {50, 8a,a,abd2,d,b,12a, d,4a2d,a2,16a2, 40b2,b}

List3   =  {4a, 5b + c,c}

List4   =  {x * *y,y * *x}
      " class="math-display" ><a 
 id="x8-980004.8.2"></a></center>
      </div>Then <span 
class="cmtt-12">NCIndependenceCheck[List1,List2,List3,List4,</span><span 
class="cmmi-12">&#x03BB;</span><span 
class="cmtt-12">]  </span>returns
      <br class="newline"><span 
class="cmsy-10x-x-120">{</span><span 
class="cmmi-12">NewList</span>1<span 
class="cmmi-12">,NewList</span>2<span 
class="cmmi-12">,NewList</span>3<span 
class="cmmi-12">,NewList</span>4<span 
class="cmsy-10x-x-120">} </span>where: <div class="eqnarray">
      <center class="math-display" >
      <img 
src="NCBIGDOC47x.png" alt="N ewList1   =   {F alse,
                     &#x03BB;3-                               5&#x03BB;11-
                {0,-  6 - 2&#x03BB;7, &#x03BB;3,0,- &#x03BB;8,- &#x03BB;13,&#x03BB;7,&#x03BB;8,-   4  ,0,&#x03BB;11,0,&#x03BB;13}}
N ewList2   =   {F alse,

                {0,- &#x03BB;3--  3&#x03BB;7,&#x03BB; ,0,- &#x03BB; ,- &#x03BB;  ,&#x03BB; ,&#x03BB;  ,- 4 &#x03BB; ,0,&#x03BB;  ,0,&#x03BB;  }}
                      8     2   3       8    13   7  8     11    11    13
N ewList3   =   True

N ewList4   =   {U ndetermined, - &#x03BB;2x * *y + &#x03BB;2y * *x, {- &#x03BB;2,&#x03BB;2}}
      " class="math-display" ></center>
      </div>In particular, what the above says is that <span 
class="cmmi-12">List</span>1<span 
class="cmmi-12">.Newlist</span>1[[2]] = 0,
      <br class="newline">and <span 
class="cmmi-12">List</span>2<span 
class="cmmi-12">.Newlist</span>2[[2]] = 0 (where &#8220;.&#8221; refers to the vector dot product). Therefore,
      the set of polynomials in <span 
class="cmmi-12">List</span>1 and <span 
class="cmmi-12">List</span>2 are dependent. <span 
class="cmmi-12">List</span>3 is independent. Note
      that <span 
class="cmmi-12">List</span>4 is clearly indpendent in the noncommutating case, and dependent in the
      commuting case. When such phenomena occur, <span 
class="cmtt-12">NCIndependenceCheck  </span>is unable to
      determine whether or not the list of polynomials is independent. However, it does
      return to the user, a set of dependencies for the <span 
class="cmmi-12">&#x03BB;</span><sub ><span 
class="cmmi-8">i</span></sub>&#8217;s which must hold in order for the
      polynomials to sum to zero.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: <span 
class="cmti-12">IndependenceCheck </span>first uses the <span 
class="cmti-12">CommuteEverything </span>command

      to make the problem feasible. Therefore it is possible that polynomials are dependent
      if  variables  commute,  and  independent  if  not.  So  in  this  case,  or  when  the  the
      expression does not collapse to zero when using the commuting coefficients with the non
      commuting polynomials, then the list <span 
class="cmsy-10x-x-120">{</span><span 
class="cmmi-12">Undertermined,expression,list</span><span 
class="cmsy-10x-x-120">} </span>is returned.
      The list element <span 
class="cmti-12">expression </span>is the sum of the polynomials with their corresponding <span 
class="cmmi-12">&#x03BB;</span>&#8217;s.
      And finally, <span 
class="cmti-12">list </span>yields a list of the dependencies for the coefficents. </dd></dl>
<a 
 id="dx8-99003"></a>
<!--l. 1843--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.8.4   </span> <a 
 id="x8-1000004.8.4"></a>NCBorderVectorGather[alist,varlist] </h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None.</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description:   <span 
class="cmtt-12">NCBorderVectorGather[alist,varlist]  </span>can   be   used   to   gather   the
      polynomial coefficents preceeding the elements given in <span 
class="cmti-12">varlist </span>whenever they occur
      in <span 
class="cmti-12">alist</span>. That is to say, <span 
class="cmti-12">alist </span>is a vector with variable entries. Each entry should end
      with some term from <span 
class="cmti-12">varlist </span>(or the transpose of some term from <span 
class="cmti-12">varlist</span>). Then for
      each element of <span 
class="cmti-12">varlist </span>the coefficients that appear in front of that element in <span 
class="cmti-12">alist </span>are
      gathered together and placed inside a list. The list returned will be a list of lists, each
      entry a list of the coefficients corresponding to the respective entries in <span 
class="cmti-12">varlist </span>and their
      transposes if they occur.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: The first argument <span 
class="cmti-12">alist </span>is a list of polynomials, all of which end in terms
      from elements of the second argument, <span 
class="cmti-12">varlist</span>, or in their transpose. <span 
class="cmti-12">alist </span>need not be
      ordered in a particular way with respect to <span 
class="cmti-12">varlist</span>. The preceeding is best explained in
      the following example.
      <br class="newline">Suppose <span 
class="cmmi-12">List </span>=
      <center class="math-display" >

      <img 
src="NCBIGDOC48x.png" alt="{A  * *B * *k, B * *B * *tp[h],B * *tp[A] * *k,B * *C * *tp[h],A * *tp[h],B * *h, C * *h}
      " class="math-display" ></center> Then <span 
class="cmtt-12">NCBorderVectorGather[List,</span><span 
class="cmsy-10x-x-120">{</span><span 
class="cmtt-12">k,h</span><span 
class="cmsy-10x-x-120">}</span><span 
class="cmtt-12">]  </span>returns the following list
      <center class="math-display" >
      <img 
src="NCBIGDOC49x.png" alt="{{A * *B, B * *tp[A]},{B, C}, {B * *B, B * *C, A}}
      " class="math-display" ></center> Note that the vectors are gather in the pattern <span 
class="cmmi-12">k,tp</span>[<span 
class="cmmi-12">k</span>]<span 
class="cmmi-12">,h,tp</span>[<span 
class="cmmi-12">h</span>]<span 
class="cmmi-12">. </span>This pattern will be
      the same despite the length of <span 
class="cmti-12">avarlist</span>.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: None. </dd></dl>
<a 
 id="dx8-100001"></a>
<!--l. 1847--><p class="noindent">
   <h3 class="sectionHead"><span class="titlemark">4.9   </span> <a 
 id="x8-1010004.9"></a>NCGuts</h3>
<a 
 id="dx8-101001"></a>
<!--l. 1851--><p class="noindent">This section details the command NCGuts, which expands the meaning of &#8220;**&#8221;, tp[], and
inv[].
<!--l. 1865--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.9.1   </span> <a 
 id="x8-1020004.9.1"></a>NCStrongProduct1</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None.</span>

      </dd><dt class="description">
 </dt><dd 
class="description">Description: NCStrongProduct1 is an option of NCGuts. When True, ** serves to multiply
      matrices as well as maintaining its original function with noncommutative entries. This
      replaces the command MatMult. For example,
      <center class="math-display" >
      <img 
src="NCBIGDOC50x.png" alt="MatMult[{{a,  b},{c, d}},{{x}, {y}}]
      " class="math-display" ></center> is the same as
      <center class="math-display" >
      <img 
src="NCBIGDOC51x.png" alt="{{a,b}, {c,d}} * *{{x}, {y}}.
      " class="math-display" ></center> In addition, <span 
class="cmmi-12">tp </span>and tpMat are the same. NCStrongProduct1 <span 
class="cmsy-10x-x-120">&#x2192; </span>False is the default.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: None.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: None. </dd></dl>
<a 
 id="dx8-102001"></a>
<!--l. 1880--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.9.2   </span> <a 
 id="x8-1030004.9.2"></a>NCStrongProduct2</h4>

      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None.</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description:   NCStrongProduct2   is   an   option   of   NCGuts.   When   set   to   true,
      if   <span 
class="cmmi-12">m  </span>is   a   matrix   with   noncommutative   entries,   inv[m]   returns   a   formula
      expression   for   the   inverse   of   <span 
class="cmmi-12">m</span>.   The   considerable   limitations   of   NCInverse
      are  still  limitations  in  inv[m].  NCStrongProduct2  forces  NCStrongProduct1.  In
      other  words,  NCGuts[NCStrongProduct2-¿True]  makes  &#8221;**&#8221;  multiply  matrices
      with   noncommutative   entries,   just   as   NCGuts[NCStrongProduct1-¿True]   does.
      NCStrongProduct2 <span 
class="cmsy-10x-x-120">&#x2192; </span>False is the default.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: None.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: None. </dd></dl>
<a 
 id="dx8-103001"></a>
<!--l. 1890--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.9.3   </span> <a 
 id="x8-1040004.9.3"></a>NCSetNC</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None.</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description:  NCSetNC  is  an  option  of  NCGuts.  When  set  to  false,  all  letters  are
      automatically  noncommutative  unless  SetCommutative  makes  them  commutative.
      NCSetNC <span 
class="cmsy-10x-x-120">&#x2192; </span>False is the default.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: None.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: None. </dd></dl>
<a 
 id="dx8-104001"></a>

<!--l. 1892--><p class="noindent">
   <h3 class="sectionHead"><span class="titlemark">4.10   </span> <a 
 id="x8-1050004.10"></a>Setting Properties of an element in an algebra</h3>
<!--l. 1904--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.10.1   </span> <a 
 id="x8-1060004.10.1"></a>SetInv[a, b, c, <span 
class="cmmi-12">&#x2026;</span>]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: <span 
class="cmmi-12">SetInv</span>[<span 
class="cmmi-12">a,b,c,</span><span 
class="cmmi-12">&#x2026;</span>] sets all the symbols <span 
class="cmmi-12">a</span>, <span 
class="cmmi-12">b</span>, <span 
class="cmmi-12">c</span>, <span 
class="cmmi-12">&#x2026;</span> to be invertible (i.e. <span 
class="cmmi-12">invQ</span>[<span 
class="cmmi-12">a</span>],
      <span 
class="cmmi-12">invQ</span>[<span 
class="cmmi-12">b</span>], <span 
class="cmmi-12">invQ</span>[<span 
class="cmmi-12">c</span>], <span 
class="cmmi-12">&#x2026;</span> are set <span 
class="cmmi-12">True</span>).
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: Symbols separated by commands
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: If one does not set <span 
class="cmmi-12">x </span>to be invertible before the first use of <span 
class="cmmi-12">invL</span>[<span 
class="cmmi-12">x</span>]
      or <span 
class="cmmi-12">invR</span>[<span 
class="cmmi-12">x</span>], then NCAlgebra may not make the substitution from <span 
class="cmmi-12">invL</span>[<span 
class="cmmi-12">x</span>] <span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x </span>to 1 or
      from <span 
class="cmmi-12">x </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">invR</span>[<span 
class="cmmi-12">x</span>] to 1 automatically. </dd></dl>
<a 
 id="dx8-106001"></a>
<!--l. 1916--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.10.2   </span> <a 
 id="x8-1070004.10.2"></a>SetSelfAdjoint[Symbols]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: SetSelfAdjoint[a, b, <span 
class="cmmi-12">&#x2026;</span>] will set a, b, <span 
class="cmmi-12">&#x2026;</span> to be self-adjoint. The rules tp[a] := a,
      tp[b] :=b, <span 
class="cmmi-12">&#x2026;</span> and aj[a] := a, aj[b] := b, <span 
class="cmmi-12">&#x2026;</span> will be automatically applied. See SelfAdjointQ.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: Symbols is one or more symbols separated by commas.

      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: If one does not set <span 
class="cmmi-12">x </span>to be self adjoint before the first use of
      <span 
class="cmmi-12">aj</span>[<span 
class="cmmi-12">x</span>], then NCAlgebra may not make the substitution from <span 
class="cmmi-12">aj</span>[<span 
class="cmmi-12">x</span>] to <span 
class="cmmi-12">x </span>automatically.
      Similary for <span 
class="cmmi-12">tp</span>. </dd></dl>
<a 
 id="dx8-107001"></a>
<!--l. 1925--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.10.3   </span> <a 
 id="x8-1080004.10.3"></a>SelfAdjointQ[aSymbol]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description:  <span 
class="cmmi-12">SelfAdjointQ</span>[<span 
class="cmmi-12">x</span>]  will  return  <span 
class="cmmi-12">True  </span>if  <span 
class="cmmi-12">SetSelfAdjoint</span>[<span 
class="cmmi-12">x</span>]  was  executed
      previously. See <span 
class="cmmi-12">SetSelfAdjoint</span>.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">aSymbol </span>is a symbol
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: None </dd></dl>
<a 
 id="dx8-108001"></a>
<!--l. 1937--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.10.4   </span> <a 
 id="x8-1090004.10.4"></a>SetIsometry[Symbols]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: <span 
class="cmmi-12">SetIsometry</span>[<span 
class="cmmi-12">a,b,</span><span 
class="cmmi-12">&#x2026;</span>] will set <span 
class="cmmi-12">a</span>, <span 
class="cmmi-12">b</span>, <span 
class="cmmi-12">&#x2026;</span> to be isometries. If set the rules tp[a] ** a
      := Id, tp[b] ** b :=Id, <span 
class="cmmi-12">&#x2026;</span> and aj[a] ** a := Id; aj[b] ** b := Id; <span 
class="cmmi-12">&#x2026;</span> will be automatically
      applied. See IsometryQ.

      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: Symbols is one or more symbols separated by commas.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: If one does not set <span 
class="cmmi-12">x </span>to be an isometry before the first use of <span 
class="cmmi-12">aj</span>[<span 
class="cmmi-12">x</span>],
      then NCAlgebra may not make the substitution from <span 
class="cmmi-12">aj</span>[<span 
class="cmmi-12">x</span>] <span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x </span>to 1 automatically.
      Similarly for <span 
class="cmmi-12">tp</span>. </dd></dl>
<a 
 id="dx8-109001"></a>
<!--l. 1946--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.10.5   </span> <a 
 id="x8-1100004.10.5"></a>IsometryQ[aSymbol]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: <span 
class="cmmi-12">IsometryQ</span>[<span 
class="cmmi-12">x</span>] will return <span 
class="cmmi-12">True </span>if <span 
class="cmmi-12">SetIsometry</span>[<span 
class="cmmi-12">x</span>] was executed previously. See
      <span 
class="cmmi-12">SetIsometry</span>.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">aSymbol </span>is a symbol.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: None </dd></dl>
<a 
 id="dx8-110001"></a>
<!--l. 1958--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.10.6   </span> <a 
 id="x8-1110004.10.6"></a>SetCoIsometry[Symbols]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: <span 
class="cmmi-12">SetCoIsometry</span>[<span 
class="cmmi-12">a,b,</span><span 
class="cmmi-12">&#x2026;</span>] will set <span 
class="cmmi-12">a</span>, <span 
class="cmmi-12">b</span>, <span 
class="cmmi-12">&#x2026;</span> to be co-isometries. The rules a ** tp[a]
      := Id, b ** tp[b] :=Id, <span 
class="cmmi-12">&#x2026;</span> and a ** aj[a] := Id, b ** aj[b] := Id, <span 
class="cmmi-12">&#x2026;</span> will be automatically
      applied. See <span 
class="cmmi-12">CoIsometryQ</span>.

      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">Symbols </span>is one or more symbols separated by commas.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: If one does not set <span 
class="cmmi-12">x </span>to be a coisometry before the first use of <span 
class="cmmi-12">aj</span>[<span 
class="cmmi-12">x</span>],
      then NCAlgebra may not make the substitution from <span 
class="cmmi-12">x </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">aj</span>[<span 
class="cmmi-12">x</span>] to 1 automatically. </dd></dl>
<a 
 id="dx8-111001"></a>
<!--l. 1967--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.10.7   </span> <a 
 id="x8-1120004.10.7"></a>CoIsometryQ[aSymbol]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description:  <span 
class="cmmi-12">CoIsometryQ</span>[<span 
class="cmmi-12">x</span>]  will  return  <span 
class="cmmi-12">True  </span>if  <span 
class="cmmi-12">SetCoIsometry</span>[<span 
class="cmmi-12">x</span>]  was  executed
      previously. See <span 
class="cmmi-12">SetCoIsometry</span>.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">aSymbol </span>is a symbol.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: None </dd></dl>
<a 
 id="dx8-112001"></a>
<!--l. 1978--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.10.8   </span> <a 
 id="x8-1130004.10.8"></a>SetUnitary[Symbols]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: <span 
class="cmmi-12">SetUnitary</span>[<span 
class="cmmi-12">a,b,</span><span 
class="cmmi-12">&#x2026;</span>] will set <span 
class="cmmi-12">a</span>, <span 
class="cmmi-12">b</span>, <span 
class="cmmi-12">&#x2026;</span> to be isometries and co-isometries. Also
      effects on <span 
class="cmmi-12">UnitaryQ</span>. See <span 
class="cmmi-12">SetIsometry </span>and <span 
class="cmmi-12">SetCoIsometry</span>.

      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">Symbols </span>is one or more symbols separated by commas.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: If one does not set <span 
class="cmmi-12">x </span>to be a unitary before the first use of <span 
class="cmmi-12">aj</span>[<span 
class="cmmi-12">x</span>],
      then NCAlgebra may not make the substitution from <span 
class="cmmi-12">x</span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">aj</span>[<span 
class="cmmi-12">x</span>] to 1 or from <span 
class="cmmi-12">aj</span>[<span 
class="cmmi-12">x</span>] <span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x</span>
      to 1 automatically. </dd></dl>
<a 
 id="dx8-113001"></a>
<!--l. 1989--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.10.9   </span> <a 
 id="x8-1140004.10.9"></a>UnitaryQ[aSymbol]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description:  <span 
class="cmmi-12">UnitaryQ</span>[<span 
class="cmmi-12">x</span>]  will  return  <span 
class="cmmi-12">True  </span>if  <span 
class="cmmi-12">SetUnitary</span>[<span 
class="cmmi-12">x</span>]  was  executed  previously.
      Caution: If one executes <span 
class="cmmi-12">SetIsometry</span>[<span 
class="cmmi-12">x</span>]; <span 
class="cmmi-12">SetCoIsometry</span>[<span 
class="cmmi-12">x</span>]; then <span 
class="cmmi-12">x </span>is unitary, but
      <span 
class="cmmi-12">UnitaryQ </span>remains uneffected. See <span 
class="cmmi-12">SetUnitary</span>.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">aSymbol </span>is a symbol.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: None </dd></dl>
<a 
 id="dx8-114001"></a>
<!--l. 2003--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.10.10   </span> <a 
 id="x8-1150004.10.10"></a>SetProjection[Symbols]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>

      </dd><dt class="description">
 </dt><dd 
class="description">Description:  <span 
class="cmmi-12">SetProjection</span>[<span 
class="cmmi-12">a,b,</span><span 
class="cmmi-12">&#x2026;</span>]  will  set  a,  b,  <span 
class="cmmi-12">&#x2026;</span> to  be  projections.  The  rules  a  **  a
      := a, b ** b :=b, <span 
class="cmmi-12">&#x2026;</span> will be automatically applied. Caution: If one wants <span 
class="cmmi-12">x </span>to be a
      self-adjoint projection, then one must execute <span 
class="cmmi-12">SetSelfAdjoint</span>[<span 
class="cmmi-12">x</span>]; <span 
class="cmmi-12">SetProjection</span>[<span 
class="cmmi-12">x</span>].
      See <span 
class="cmmi-12">ProjectionQ</span>.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">Symbols </span>is one or more symbols separated by commas.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: If one does not set <span 
class="cmmi-12">x </span>to be a projection before the first use of <span 
class="cmmi-12">x</span>,
      then NCAlgebra may not make the substitution from <span 
class="cmmi-12">x </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x </span>to <span 
class="cmmi-12">x</span>. </dd></dl>
<a 
 id="dx8-115001"></a>
<!--l. 2013--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.10.11   </span> <a 
 id="x8-1160004.10.11"></a>ProjectionQ[S]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: <span 
class="cmmi-12">ProjectionQ</span>[<span 
class="cmmi-12">x</span>] will return true if <span 
class="cmmi-12">SetProjection</span>[<span 
class="cmmi-12">x</span>] was executed previously.
      See <span 
class="cmmi-12">SetProjection</span>.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">S </span>is a symbol.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: None </dd></dl>
<a 
 id="dx8-116001"></a>
<!--l. 2025--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.10.12   </span> <a 
 id="x8-1170004.10.12"></a>SetSignature[Symbols]</h4>

      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: When <span 
class="cmmi-12">SetSignature</span>[<span 
class="cmmi-12">a</span>] and <span 
class="cmmi-12">SetSelfAdjoint</span>[<span 
class="cmmi-12">a</span>] are executed, the rule a ** a
      := -1 will be automatically applied. See <span 
class="cmmi-12">SetSelfAdjoint </span>and <span 
class="cmmi-12">SignatureQ</span>.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">Symbols </span>is one or more symbols separated by commas.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: If one does not set <span 
class="cmmi-12">x </span>to be a signature matrix and self adjoing
      before the first use of <span 
class="cmmi-12">x</span>, then NCAlgebra may not make the substitution from <span 
class="cmmi-12">x </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x</span>
      to <span 
class="cmsy-10x-x-120">-</span>1. </dd></dl>
<a 
 id="dx8-117001"></a>
<!--l. 2034--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.10.13   </span> <a 
 id="x8-1180004.10.13"></a>SignatureQ[Symbol]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: <span 
class="cmmi-12">SignatureQ</span>[<span 
class="cmmi-12">x</span>] will return <span 
class="cmmi-12">True </span>if <span 
class="cmmi-12">SetSignature</span>[<span 
class="cmmi-12">x</span>] was executed previously.
      See <span 
class="cmmi-12">SetSignature</span>.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">Symbol </span>is a symbol.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: None </dd></dl>
<a 
 id="dx8-118001"></a>
<!--l. 2036--><p class="noindent">
   <h3 class="sectionHead"><span class="titlemark">4.11   </span> <a 
 id="x8-1190004.11"></a>Setting Properties of functions on an algebra</h3>

<!--l. 2046--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.11.1   </span> <a 
 id="x8-1200004.11.1"></a>SetSesquilinear[Functions]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">SetSesq</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description:  <span 
class="cmmi-12">SetSesquilinear</span>[<span 
class="cmmi-12">a,b,c,</span><span 
class="cmmi-12">&#x2026;</span>]  sets  <span 
class="cmmi-12">a</span>,  <span 
class="cmmi-12">b</span>,  <span 
class="cmmi-12">c</span>,  <span 
class="cmmi-12">&#x2026;</span> to  be  functions  of  two  variables
      which are linear in the first variable and conjugate linear in the second variable. See
      SetBilinear.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">Functions </span>is one or more symbols separated by commas.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: None </dd></dl>
<a 
 id="dx8-120001"></a>
<!--l. 2055--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.11.2   </span> <a 
 id="x8-1210004.11.2"></a>SesquilinearQ[aFunction]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description:  <span 
class="cmmi-12">SesquilinearQ</span>[<span 
class="cmmi-12">x</span>]  will  return  <span 
class="cmmi-12">True  </span>if  <span 
class="cmmi-12">SetSesquilinear</span>[<span 
class="cmmi-12">x</span>]  was  executed
      previously. See <span 
class="cmmi-12">SetSesquilinear</span>.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">aFunction </span>is a symbol.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: None </dd></dl>
<a 
 id="dx8-121001"></a>

<!--l. 2065--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.11.3   </span> <a 
 id="x8-1220004.11.3"></a>SetBilinear[Functions]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: <span 
class="cmmi-12">SetBilinear</span>[<span 
class="cmmi-12">a,b,c,</span><span 
class="cmmi-12">&#x2026;</span>] sets <span 
class="cmmi-12">a</span>, <span 
class="cmmi-12">b</span>, <span 
class="cmmi-12">c</span>, <span 
class="cmmi-12">&#x2026;</span> to be functions of two variables which is
      linear in the first variable and linear in the second variable. See SetSesquilinear.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: Functions is one or more symbols separated by commas.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: None </dd></dl>
<a 
 id="dx8-122001"></a>
<!--l. 2074--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.11.4   </span> <a 
 id="x8-1230004.11.4"></a>BilinearQ[aFunction]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: <span 
class="cmmi-12">BilinearQ</span>[<span 
class="cmmi-12">x</span>] will return True if <span 
class="cmmi-12">SetBilinear</span>[<span 
class="cmmi-12">x</span>] was executed previously. See
      <span 
class="cmmi-12">SetBilinear</span>.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">aFunction </span>is a symbol.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: None </dd></dl>
<a 
 id="dx8-123001"></a>

<!--l. 2083--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.11.5   </span> <a 
 id="x8-1240004.11.5"></a>SetLinear[Functions]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: <span 
class="cmmi-12">SetLinear</span>[<span 
class="cmmi-12">b,c,d,</span><span 
class="cmmi-12">&#x2026;</span>] sets <span 
class="cmmi-12">b</span>, <span 
class="cmmi-12">c</span>, <span 
class="cmmi-12">d</span>, <span 
class="cmmi-12">&#x2026;</span> to be functions of one variable which are
      linear. See <span 
class="cmmi-12">LinearQ</span>.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">Functions </span>is one or more symbols separated by commas.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: None </dd></dl>
<a 
 id="dx8-124001"></a>
<!--l. 2092--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.11.6   </span> <a 
 id="x8-1250004.11.6"></a>LinearQ[aFunction]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: <span 
class="cmmi-12">LinearQ</span>[<span 
class="cmmi-12">x</span>] will return <span 
class="cmmi-12">True </span>if <span 
class="cmmi-12">SetLinear</span>[<span 
class="cmmi-12">x</span>] was executed previously. See
      <span 
class="cmmi-12">SetLinear</span>.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">aFunction </span>is a symbol.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: None </dd></dl>
<a 
 id="dx8-125001"></a>

<!--l. 2101--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.11.7   </span> <a 
 id="x8-1260004.11.7"></a>SetConjugateLinear[Functions]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: <span 
class="cmmi-12">SetConjugateLinear</span>[<span 
class="cmmi-12">b,c,d,</span><span 
class="cmmi-12">&#x2026;</span>] sets <span 
class="cmmi-12">b</span>, <span 
class="cmmi-12">c</span>, <span 
class="cmmi-12">d</span>, <span 
class="cmmi-12">&#x2026;</span> to be functions of one variable
      which are conjugate linear. See <span 
class="cmmi-12">ConjugateLinearQ</span>.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">Functions </span>is one or more symbols separated by commas.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: None </dd></dl>
<a 
 id="dx8-126001"></a>
<!--l. 2110--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.11.8   </span> <a 
 id="x8-1270004.11.8"></a>ConjugateLinearQ[aFunction]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description:  <span 
class="cmmi-12">ConjugateLinearQ</span>[<span 
class="cmmi-12">x</span>]  will  return  True  if  <span 
class="cmmi-12">SetConjugateLinear</span>[<span 
class="cmmi-12">x</span>]  was
      executed previously. See <span 
class="cmmi-12">SetConjugateLinear</span>.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: aFunction is a symbol.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: None </dd></dl>
<a 
 id="dx8-127001"></a>

<!--l. 2120--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.11.9   </span> <a 
 id="x8-1280004.11.9"></a>SetIdempotent[Functions]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: <span 
class="cmmi-12">SetIdempotent</span>[<span 
class="cmmi-12">b,c,d,</span><span 
class="cmmi-12">&#x2026;</span>] sets <span 
class="cmmi-12">b</span>, <span 
class="cmmi-12">c</span>, <span 
class="cmmi-12">d</span>, <span 
class="cmmi-12">&#x2026;</span> to be functions of one variable such that,
      for example, <span 
class="cmmi-12">b</span>[<span 
class="cmmi-12">b</span>[<span 
class="cmmi-12">z</span>_]] := <span 
class="cmmi-12">z</span>; Common examples are inverse, transpose and adjoint. See
      IdempotentQ.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">Functions </span>is one or more symbols separated by commas.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: None </dd></dl>
<a 
 id="dx8-128001"></a>
<!--l. 2129--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.11.10   </span> <a 
 id="x8-1290004.11.10"></a>IdempotentQ[aFunction]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: <span 
class="cmmi-12">IdempotentQ</span>[<span 
class="cmmi-12">x</span>] will return <span 
class="cmmi-12">True </span>if <span 
class="cmmi-12">SetIdempotent</span>[<span 
class="cmmi-12">x</span>] was executed previously
      and False otherwise. See <span 
class="cmmi-12">SetIdempotent</span>.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">aFunction </span>is a symbol.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: None </dd></dl>
<a 
 id="dx8-129001"></a>

<!--l. 2148--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.11.11   </span> <a 
 id="x8-1300004.11.11"></a>SetCommutingFunctions[ aFunction, anotherFunction]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description:       SetCommutingFunctions       takes       exactly       two       parameters.
      SetCommutingFunctions[b, c] will implement the definitions <span 
class="cmmi-12">b</span>[<span 
class="cmmi-12">c</span>[<span 
class="cmmi-12">z</span>___]]  :=  <span 
class="cmmi-12">c</span>[<span 
class="cmmi-12">b</span>[<span 
class="cmmi-12">z</span>]] /;
      <span 
class="cmmi-12">Not</span>[<span 
class="cmmi-12">LeftQ</span>[<span 
class="cmmi-12">b,c</span>]]; and <span 
class="cmmi-12">c</span>[<span 
class="cmmi-12">b</span>[<span 
class="cmmi-12">z</span>___]] := <span 
class="cmmi-12">b</span>[<span 
class="cmmi-12">c</span>[<span 
class="cmmi-12">z</span>]] /; LeftQ[b, c]; Common examples are the
      adjoint commuting with the transpose. Note: The above implementation will NOT lead
      to infinite loops. WARNING: If one says SetCommutingFunctions[b, c] and then sets
      only LeftQ[c,b], then neither of the above rules will be executed. Therefore, one must
      remember the order of the two parameters in the statement. One obvious helpful habit
      would be to use alphabetical order (i.e. say SetCommutingFunctions[aj, tp] and not
      the reverse). See <span 
class="cmmi-12">CommutatingOperators </span>and <span 
class="cmmi-12">LeftQ</span>.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">aFunction </span>and <span 
class="cmmi-12">anotherFunction </span>are symbols.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: None </dd></dl>
<a 
 id="dx8-130001"></a>
<!--l. 2164--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.11.12   </span> <a 
 id="x8-1310004.11.12"></a>SetNonCommutativeMultiplyAntihomomorphism[ Functions]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: <span 
class="cmmi-12">SetNonCommutativeMultiplyAntihomomorphism</span>[<span 
class="cmmi-12">b,c,d,</span><span 
class="cmmi-12">&#x2026;</span>] sets <span 
class="cmmi-12">b</span>, <span 
class="cmmi-12">c</span>, <span 
class="cmmi-12">d</span>, ... to
      be functions of one variable such that, for example, <span 
class="cmmi-12">b</span>[<span 
class="cmmi-12">anything</span>1<span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">anything</span>2] becomes
      <span 
class="cmmi-12">b</span>[<span 
class="cmmi-12">anything</span>2] <span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">b</span>[<span 
class="cmmi-12">anything</span>1]  if  <span 
class="cmmi-12">ExpandQ</span>[<span 
class="cmmi-12">b</span>]  is  True;  b[anything2]  **  b[anything1]
      becomes b[anything1 ** anything2] if <span 
class="cmmi-12">ExpandQ</span>[<span 
class="cmmi-12">b</span>] is False; Common examples are
      inverse, transpose and adjoint. NOTE: The synonym NCAntihomo is easier to type.

      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">Functions </span>is one or more symbols separated by commas.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: None </dd></dl>
<a 
 id="dx8-131001"></a>
<!--l. 2166--><p class="noindent">
   <h3 class="sectionHead"><span class="titlemark">4.12   </span> <a 
 id="x8-1320004.12"></a>Manipulating an Expression &#8212; less useful commands</h3>
<!--l. 2181--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.12.1   </span> <a 
 id="x8-1330004.12.1"></a>NCTermArray[expr,aList,anArray]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description:        <span 
class="cmmi-12">NCTermArray</span>[<span 
class="cmmi-12">expr,aList,anArray</span>]        creates        an        array
      <span 
class="cmmi-12">anArray </span>whose contents represent the terms of <span 
class="cmmi-12">expr </span>sorted by degree. The variables
      <span 
class="cmmi-12">anArray</span>[&#8221;<span 
class="cmmi-12">variables</span>&#8221;], <span 
class="cmmi-12">anArray</span>[&#8221;<span 
class="cmmi-12">types</span>&#8221;] and elements such as <span 
class="cmmi-12">anArray</span>[<span 
class="cmmi-12">x</span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x,y</span>] and
      <span 
class="cmmi-12">anArray</span>[<span 
class="cmmi-12">x </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">x,y </span><span 
class="cmsy-10x-x-120">**</span><span 
class="cmmi-12">y</span>] to hold the terms with 2 x&#8216;s and 1 y and 3 x&#8217;s and 2 y&#8217;s,
      respectively (assuming that <span 
class="cmmi-12">aList </span>= <span 
class="cmsy-10x-x-120">{</span>x,y<span 
class="cmsy-10x-x-120">}</span>). You can reconstruct <span 
class="cmmi-12">expr </span>from <span 
class="cmmi-12">anArray</span>
      via ReconstuctTaylor[anArray].
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">expr </span>is an algebraic expression, <span 
class="cmmi-12">aList </span>is a list of variables and <span 
class="cmmi-12">anArray </span>is a
      symbol.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: Not available before NCAlgebra 1.0 </dd></dl>
<a 
 id="dx8-133001"></a>
<!--l. 2183--><p class="noindent">The following is an example of the above command.

   <table width="100%" 
class="verbatim"><tr class="verbatim"><td 
class="verbatim"><div class="verbatim">
In[22]:=&#x00A0;expr&#x00A0;=&#x00A0;x&#x00A0;**&#x00A0;z&#x00A0;**&#x00A0;x&#x00A0;**&#x00A0;w&#x00A0;+&#x00A0;x&#x00A0;**&#x00A0;z&#x00A0;**&#x00A0;y&#x00A0;**&#x00A0;w&#x00A0;+&#x00A0;z&#x00A0;**&#x00A0;x&#x00A0;**&#x00A0;x&#x00A0;**&#x00A0;w&#x00A0;+
&#x00A0;<br />&#x00A0;&#x00A0;&#x00A0;&#x00A0;z&#x00A0;**&#x00A0;x&#x00A0;**&#x00A0;y&#x00A0;**&#x00A0;w;
&#x00A0;<br />
&#x00A0;<br />
&#x00A0;<br />In[23]:=&#x00A0;NCTermArray[expr,{x,y},foo]
&#x00A0;<br />
&#x00A0;<br />Out[23]=&#x00A0;foo
&#x00A0;<br />
&#x00A0;<br />In[24]:=&#x00A0;??foo
&#x00A0;<br />Global&#8216;foo
&#x00A0;<br />
&#x00A0;<br />foo["types"]&#x00A0;=&#x00A0;{{1,&#x00A0;1},&#x00A0;{2,&#x00A0;0}}
&#x00A0;<br />
&#x00A0;<br />foo["variables"]&#x00A0;:=&#x00A0;{x,&#x00A0;y}
&#x00A0;<br />
&#x00A0;<br />foo[x,&#x00A0;y]&#x00A0;=&#x00A0;x&#x00A0;**&#x00A0;z&#x00A0;**&#x00A0;y&#x00A0;**&#x00A0;w&#x00A0;+&#x00A0;z&#x00A0;**&#x00A0;x&#x00A0;**&#x00A0;y&#x00A0;**&#x00A0;w
&#x00A0;<br />
&#x00A0;<br />foo[x&#x00A0;**&#x00A0;x,&#x00A0;1]&#x00A0;=&#x00A0;x&#x00A0;**&#x00A0;z&#x00A0;**&#x00A0;x&#x00A0;**&#x00A0;w&#x00A0;+&#x00A0;z&#x00A0;**&#x00A0;x&#x00A0;**&#x00A0;x&#x00A0;**&#x00A0;w
&#x00A0;<br />
&#x00A0;<br />foo[x___]&#x00A0;:=&#x00A0;0
</div>
</td></tr></table>
<!--l. 2206--><p class="nopar">
<!--l. 2215--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.12.2   </span> <a 
 id="x8-1340004.12.2"></a>NCReconstructFromTermArray[anArray]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: <span 
class="cmmi-12">NCTermArray</span>[<span 
class="cmmi-12">expr,aList,anArray</span>];

      <center class="math-display" >
      <img 
src="NCBIGDOC52x.png" alt="newexpr   = N CReconstructF   romT ermArray[anArray];
      " class="math-display" ></center> sets <span 
class="cmmi-12">newexpr </span>equal to <span 
class="cmmi-12">expr</span>.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">anArray </span>is a symbol previously filled by NCTermArray
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: Not available before NCAlgebra 1.0 </dd></dl>
<a 
 id="dx8-134001"></a>
<!--l. 2217--><p class="noindent">If we continue with the example above we have the following

   <table width="100%" 
class="verbatim"><tr class="verbatim"><td 
class="verbatim"><div class="verbatim">
In[24]:=&#x00A0;NCReconstructFromTermArray[foo]
&#x00A0;<br />
&#x00A0;<br />Out[24]=&#x00A0;x&#x00A0;**&#x00A0;z&#x00A0;**&#x00A0;x&#x00A0;**&#x00A0;w&#x00A0;+&#x00A0;x&#x00A0;**&#x00A0;z&#x00A0;**&#x00A0;y&#x00A0;**&#x00A0;w&#x00A0;+&#x00A0;z&#x00A0;**&#x00A0;x&#x00A0;**&#x00A0;x&#x00A0;**&#x00A0;w&#x00A0;+
&#x00A0;<br />
&#x00A0;<br />&gt;&#x00A0;&#x00A0;&#x00A0;&#x00A0;z&#x00A0;**&#x00A0;x&#x00A0;**&#x00A0;y&#x00A0;**&#x00A0;w
&#x00A0;<br />
</div>
</td></tr></table>
<!--l. 2225--><p class="nopar">
<!--l. 2227--><p class="indent">   However, now one can also do some manipulation before reconstructing as shown
below.

   <table width="100%" 
class="verbatim"><tr class="verbatim"><td 
class="verbatim"><div class="verbatim">
In[25]:=&#x00A0;foo[x,y]&#x00A0;=&#x00A0;NCC[foo[x,y],y**w]
&#x00A0;<br />Out[25]=&#x00A0;(x&#x00A0;**&#x00A0;z&#x00A0;+&#x00A0;z&#x00A0;**&#x00A0;x)&#x00A0;**&#x00A0;y&#x00A0;**&#x00A0;w
&#x00A0;<br />
&#x00A0;<br />In[26]:=&#x00A0;foo[x**x,1]&#x00A0;=&#x00A0;NCC[foo[x**x,1],x**w]
&#x00A0;<br />
&#x00A0;<br />Out[26]=&#x00A0;(x&#x00A0;**&#x00A0;z&#x00A0;+&#x00A0;z&#x00A0;**&#x00A0;x)&#x00A0;**&#x00A0;x&#x00A0;**&#x00A0;w
&#x00A0;<br />
&#x00A0;<br />In[27]:=&#x00A0;??foo
&#x00A0;<br />Global&#8216;foo
&#x00A0;<br />
&#x00A0;<br />foo["types"]&#x00A0;=&#x00A0;{{1,&#x00A0;1},&#x00A0;{2,&#x00A0;0}}
&#x00A0;<br />
&#x00A0;<br />foo["variables"]&#x00A0;:=&#x00A0;{x,&#x00A0;y}
&#x00A0;<br />
&#x00A0;<br />foo[x,&#x00A0;y]&#x00A0;=&#x00A0;NCC[x&#x00A0;**&#x00A0;z&#x00A0;**&#x00A0;y&#x00A0;**&#x00A0;w&#x00A0;+&#x00A0;z&#x00A0;**&#x00A0;x&#x00A0;**&#x00A0;y&#x00A0;**&#x00A0;w,&#x00A0;y&#x00A0;**&#x00A0;w]
&#x00A0;<br />
&#x00A0;<br />foo[x&#x00A0;**&#x00A0;x,&#x00A0;1]&#x00A0;=&#x00A0;NCC[x&#x00A0;**&#x00A0;z&#x00A0;**&#x00A0;x&#x00A0;**&#x00A0;w&#x00A0;+&#x00A0;z&#x00A0;**&#x00A0;x&#x00A0;**&#x00A0;x&#x00A0;**&#x00A0;w,&#x00A0;x&#x00A0;**&#x00A0;w]
&#x00A0;<br />
&#x00A0;<br />foo[x___]&#x00A0;:=&#x00A0;0
&#x00A0;<br />
&#x00A0;<br />In[27]:=&#x00A0;NCReconstructFromTermArray[foo]
&#x00A0;<br />Out[27]=&#x00A0;(x&#x00A0;**&#x00A0;z&#x00A0;+&#x00A0;z&#x00A0;**&#x00A0;x)&#x00A0;**&#x00A0;x&#x00A0;**&#x00A0;w&#x00A0;+&#x00A0;(x&#x00A0;**&#x00A0;z&#x00A0;+&#x00A0;z&#x00A0;**&#x00A0;x)&#x00A0;**&#x00A0;y&#x00A0;**&#x00A0;w
&#x00A0;<br />
</div>
</td></tr></table>
<!--l. 2254--><p class="nopar">
<!--l. 2269--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.12.3   </span> <a 
 id="x8-1350004.12.3"></a>NCCompose[aVerySpecialList]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">NCCom</span>

      </dd><dt class="description">
 </dt><dd 
class="description">Description:  <span 
class="cmmi-12">NCCompose</span>[<span 
class="cmmi-12">NCDecompose</span>[<span 
class="cmmi-12">poly,a</span>]]  will  reproduce  <span 
class="cmmi-12">poly</span>.  For  example,
      <span 
class="cmmi-12">NCCompose</span>[<span 
class="cmmi-12">NCDecompose</span>[<span 
class="cmmi-12">poly,</span><span 
class="cmmi-12">a,b</span>]<span 
class="cmmi-12">,</span> 1<span 
class="cmmi-12">, </span>0]  will  reconstruct  the  elements  of  poly
      which are of order 1 in <span 
class="cmmi-12">a </span>and of order 0 in <span 
class="cmmi-12">b</span>.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments:
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: Called within NCCollect. <span 
class="cmbx-12">The average user would never use</span>
      <span 
class="cmbx-12">this.  </span></dd></dl>
<a 
 id="dx8-135001"></a>
<!--l. 2279--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.12.4   </span> <a 
 id="x8-1360004.12.4"></a>NCDecompose[expr, listofsymbols]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">NCDec</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: NCDecompose[poly, a] or NCDecompose[poly, a, b, c, ...] will produce a list of
      elements of poly in which elements of the same order of a (or the same order of a, b,
      c, ... ) are collected together.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments:
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: Called within NCCollect. <span 
class="cmbx-12">The average user would never use</span>
      <span 
class="cmbx-12">this. </span></dd></dl>
<a 
 id="dx8-136001"></a>
<!--l. 2290--><p class="noindent">
   <h3 class="sectionHead"><span class="titlemark">4.13   </span> <a 
 id="x8-1370004.13"></a>Utilities</h3>

<!--l. 2292--><p class="noindent">Most of these utilities are for saving things. They probably do not work nor will you wish to use
them in the Notebook environment.
<!--l. 2316--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.13.1   </span> <a 
 id="x8-1380004.13.1"></a>SaveRules[expression, &#8217;optional tag <span 
class="cmsy-10x-x-120">&#x2192; </span>&#8221;message&#8221;&#8217;]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">SaveR</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: Its main purpose is to control the Rules.temp file which records the rules used
      any time a Substitute command is used.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">SaveRules</span>[<span 
class="cmmi-12">On</span>] turns on the Rules.temp for continuous recording of rules.
      <span 
class="cmmi-12">SaveRules</span>[<span 
class="cmmi-12">Off</span>] turns off the continuous record feature of Substitute commands, but
      any Substitute command can make a record in Rules.temp by using On as its optional
      argument. <span 
class="cmmi-12">SaveRules</span>[<span 
class="cmmi-12">expression</span>] will save the evaluated form of <span 
class="cmmi-12">expression </span>to the
      Rules.temp. <span 
class="cmmi-12">SaveRules</span>[<span 
class="cmmi-12">expression,tag </span><span 
class="cmsy-10x-x-120">&#x2192; </span>&#8221;<span 
class="cmmi-12">message</span>&#8221;] will save the evaluated form of
      &#8217;expression&#8217; to the Rules.temp file with a explanatory message.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: SaveRules[&#8221;ccc&#8221;], where ccc is a string, can be used to include
      comments into the Rules.temp file. SaveRules[mathematical expression] will record the
      mathematical expression without its definitions. </dd></dl>
<a 
 id="dx8-138001"></a>
<!--l. 2327--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.13.2   </span> <a 
 id="x8-1390004.13.2"></a>SaveRulesQ[]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">SaveRQ</span>

      </dd><dt class="description">
 </dt><dd 
class="description">Description:  SaveRulesQ[]  indicates  the  status  of  the  continuous  recording  feature  of
      the Substitute commands into the Rules.temp file by message and returns True if
      continuous records are being made and False if continuous records are not being made.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: None
      </dd><dt class="description">
 </dt><dd 
class="description">Comments  /  Limitations:  Messages  can  be  suppressed  or  enabled  by  typing  Off[
      SaveRulesQ::Off] and On[SaveRulesQ::On]. </dd></dl>
<a 
 id="dx8-139001"></a>
<!--l. 2341--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.13.3   </span> <a 
 id="x8-1400004.13.3"></a>FunctionOnRules[Rules, Function1, Function2, (optional On)]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">FORules</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description: It maps <span 
class="cmmi-12">Function</span>1 onto the left hand side and <span 
class="cmmi-12">Function</span>2 onto the right
      hand side of each rule in a set of rules, and returns the new set of rule. For example,
      FunctionOnRules[ <span 
class="cmsy-10x-x-120">{ </span>a<span 
class="cmsy-10x-x-120">&#x2192; </span>x, b<span 
class="cmsy-10x-x-120">&#x2192; </span>y <span 
class="cmsy-10x-x-120">}</span>, Sin, Cos] gives <span 
class="cmsy-10x-x-120">{</span>Sin[a] <span 
class="cmsy-10x-x-120">&#x2192; </span>Cos[x], Sin[b] <span 
class="cmsy-10x-x-120">&#x2192; </span>Cos[y]
      <span 
class="cmsy-10x-x-120">}</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmmi-12">Rules </span>is a single rule or list of rules. <span 
class="cmmi-12">Function</span>1 and <span 
class="cmmi-12">Function</span>2 are any built-in
      Mathematica function, NCAlgebra function, pure function, or user-defined function.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: None </dd></dl>
<a 
 id="dx8-140001"></a>

<!--l. 2344--><p class="noindent">
   <h3 class="sectionHead"><span class="titlemark">4.14   </span> <a 
 id="x8-1410004.14"></a>Deprecated Commands</h3>
<!--l. 2346--><p class="noindent">The following commands are no longer supported in this version of NCAlgebra.
<!--l. 2365--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.14.1   </span> <a 
 id="x8-1420004.14.1"></a>RandomMatrix[m,n,min,max,options]</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None.</span>
      </dd><dt class="description">
 </dt><dd 
class="description">Description:  <span 
class="cmtt-12">RandomMatrix[ m, n, min, max, options ] </span>returns  a  random  matrix  of
      size <span 
class="cmtt-12">m </span>by <span 
class="cmtt-12">n </span>with entries between the values <span 
class="cmtt-12">min </span>and <span 
class="cmtt-12">max</span>.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: <span 
class="cmtt-12">m </span>and <span 
class="cmtt-12">n </span>are the number of rows and columns of the matrix. <span 
class="cmtt-12">min </span>and <span 
class="cmtt-12">max</span>
      are the minimum and maximum values of the entries in the matrix. The options are
      <span 
class="cmtt-12">MatrixType </span>and <span 
class="cmtt-12">EntryType</span>. The option <span 
class="cmtt-12">MatrixType </span>has values <span 
class="cmtt-12">Any</span>, <span 
class="cmtt-12">Diagonal</span>, or
      <span 
class="cmtt-12">Symmetric</span>. The default is <span 
class="cmtt-12">MatrixType </span><span 
class="cmsy-10x-x-120">&#x2192; </span><span 
class="cmtt-12">Any </span>which returns an ordinary unrestricted
      matrix. <span 
class="cmtt-12">MatrixType </span><span 
class="cmsy-10x-x-120">&#x2192; </span><span 
class="cmtt-12">Diagonal </span>returns random diagonal matrices. <span 
class="cmtt-12">MatrixType </span><span 
class="cmsy-10x-x-120">&#x2192;</span>
      <span 
class="cmtt-12">Symmetric </span>returns random symmetric matrices.  The option <span 
class="cmtt-12">EntryType </span>has values
      <span 
class="cmtt-12">Integer </span>or <span 
class="cmtt-12">Real</span>. The default is <span 
class="cmtt-12">EntryType </span><span 
class="cmsy-10x-x-120">&#x2192; </span><span 
class="cmtt-12">Real </span>which produces real floating point
      numbers as entries for the random matrix. <span 
class="cmtt-12">EntryType </span><span 
class="cmsy-10x-x-120">&#x2192; </span><span 
class="cmtt-12">Integer </span>produces integers
      as entries.
      </dd><dt class="description">
 </dt><dd 
class="description">Comments / Limitations: Functionality provided by new RandomInteger, RandomDouble,
      etc, native Mathematica commands </dd></dl>
<a 
 id="dx8-142001"></a>
<!--l. 2397--><p class="noindent">
   <h4 class="subsectionHead"><span class="titlemark">4.14.2   </span> <a 
 id="x8-1430004.14.2"></a>CEEP</h4>
      <dl class="description"><dt class="description">
 </dt><dd 
class="description">Aliases: <span 
class="cmbx-12">None</span>

      </dd><dt class="description">
 </dt><dd 
class="description">Description:  The &#8220;CEEP&#8221; file tells Mathematica that you want to record the functions you
      use during the session for later use or examination. It prompts you for a file name. Say
      you respond MYSESSION. CEEP records your session &#8211; two different ways into two
      different files &#8211; the first file (e.g. MYSESSION.m and MYSESSION.ex) records the In[]
      and Out[] lines of code you see on the screen and the second file (which contains the
      suffix .ex &#8211; MYSESSION.ex in the above example) saves just the commands which you
      type.
      <br class="newline">
      <br class="newline">Functions stored in these files can be brought into a Mathematica session at a later
      time by typing <span 
class="cmsy-10x-x-120">&#x226A;</span><span 
class="cmtt-12">MYSESSION.ex </span>and it executes. This file can also be modified in a
      text editor external to the Mathematica program. The &#8220;NCAlgebra.m&#8221; file contains
      the  instructions  to  load  NCAlgebra  &#8220;packages&#8221;  which  allow  the  manipulation  of
      noncommutative expressions.
      <br class="newline">
      <br class="newline">Also, when using UNIX via a UNIX shell (rather than a Mathematica notebook), UNIX
      has a &#8217;script&#8217; utility which can be used. Type &#8217;man script&#8217; to find out more.
      </dd><dt class="description">
 </dt><dd 
class="description">Arguments: None
      </dd><dt class="description">
 </dt><dd 
class="description">Comments  /  Limitations:  Fails  inside  a  Notebook.  You  can  essentially  achieve  the
      same  functionality  by  using  file=OpenAppend[&#8221;filename&#8221;];  AppendTo[$Echo,  file];
      If  <span class="TEX">T<span 
class="E">E</span>X</span>formating  is  desired  use  file=OpenAppend[&#8221;filename&#8221;,  FormatType  <span 
class="cmsy-10x-x-120">- </span><span 
class="cmmi-12">&gt;</span>
      NCTeXForm];  </dd></dl>
<a 
 id="dx8-143001"></a>



   <!--l. 1--><div class="crosslinks"><p class="noindent">[<a 
href="NCBIGDOCch5.html" >next</a>] [<a 
href="NCBIGDOCch3.html" >prev</a>] [<a 
href="NCBIGDOCch3.html#tailNCBIGDOCch3.html" >prev-tail</a>] [<a 
href="NCBIGDOCch4.html" >front</a>] [<a 
href="NCBIGDOCpa1.html#NCBIGDOCch4.html" >up</a>] </p></div>
<!--l. 1--><p class="indent">   <a 
 id="tailNCBIGDOCch4.html"></a>     
</body></html> 
