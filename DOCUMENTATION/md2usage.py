import enum
import getopt
import sys
import re
import os
import subprocess
import datetime

def usage():
    print('md2usage')
    print("""usage: md2usage [option] filename
Options are:
-H arg : set command heading level        (default '##')
-h     : print this help message and exit
-o arg : output file name                 (default stdout)
""")

class State(enum.Enum):
     idle = 0
     scanning = 1

def main():

    # Parse command line
    try:
        opts, args = getopt.getopt(sys.argv[1:], "hH:o:", ["help"])

    except getopt.GetoptError as err:
        # print help information and exit:
        print('server: illegal option {}'.format(sys.argv[1:]))
        usage()
        sys.exit(2)

    #print("args = {}".format(args))
    #print("opts = {}".format(opts))

    if len(args) == 0:
        print('ERROR: missing filename')
        opts = (('-h', ''), )
        
    HEADING = '##'
    CONVERT = ['pandoc', '-t', 'plain', '--wrap=none']
    outfile = None
    debug = True

    for o, a in opts:
        if o in ("-h", "--help"):
            usage()
            sys.exit()
        elif o == "-H":
            HEADING = a
        elif o == "-o":
            outfile = a
        else:
            assert False, "unhandled option"

    # build higher heading pattern
    HIGHER_HEADING = ''
    higher_headings_pattern = None
    if len(HEADING) > 1:
        pattern = '(' + '|'.join([HEADING[:i] for i in range(1,len(HEADING))]) + ')'
        higher_headings_pattern = re.compile(pattern + "\s*(\w+)")

    # patterns
    heading_pattern = re.compile(HEADING + "\s*(\w+)");
    name_pattern = re.compile(r"(<a\s)|(</a>)");

    # filename
    filename = args[0]

    # function dictionary
    functions = {};

    # Read file
    with open(filename, 'r') as f:
        mode = State.idle
        function = ""
        body = ""
        for line in f:
            # match name pattern
            if re.match(name_pattern, line) is not None:
                # ignore
                if debug:
                    print('> NAME MATCH: {}'.format(line), file = sys.stderr)
                continue

            # match higher heading
            if higher_headings_pattern is not None and re.match(higher_headings_pattern, line) is not None and mode == State.scanning:
                # finished function
                functions[function] = body
                if debug:
                    print('< HIGHER HEADING', file = sys.stderr)
                    print('< END FUNCTION', file = sys.stderr)
                # set to idle
                mode == State.idle
                # and continue with next line
                continue
            
            # match heading pattern
            match = re.match(heading_pattern, line)
            if match is not None:
                if mode == State.scanning:
                    # finished function
                    functions[function] = body
                    if debug:
                        print('< END FUNCTION', file = sys.stderr)
                elif mode == State.idle:
                    # go into scanning mode
                    mode = State.scanning
                    if debug:
                        print('> SCANNING...', file = sys.stderr)
                # retrieve function name
                function = match.group(1)
                # reset body
                body = ""
                if debug:
                    print('> BEGIN FUNCTION: {}'.format(function), file = sys.stderr)
            else:
                body += line

        if mode == State.scanning:
            # finished function
            functions[function] = body
            if debug:
                print('> END FUNCTION', file = sys.stderr)
                
        if debug:
            print('< END FILE', file = sys.stderr)
                
    # produce output file
    fsock = None
    if outfile:
        fsock = open(outfile, 'w')
        # add header
        now = datetime.datetime.now()
        print("""\
(*************************************************************************
 *         This file was automatically generated by md2usage.py          *
 *                   on {}                       *
 *************************************************************************)
""".format(now), file = fsock)

    # print functions
    for key, value in functions.items():
        # process body
        proc = subprocess.Popen(CONVERT,        
                                stdin=subprocess.PIPE,
                                stdout=subprocess.PIPE)
        output = proc.communicate(value.encode('utf-8'))[0].decode('utf-8')

        # escape slash
        output = re.sub(r'\\', r'\\\\', output)

        # protect quotes
        output = output.replace('"', '\\"')

        # print comment
        print('\n(* ' + key + ' *)', file=fsock)

        # print usage statement
        print(key + '::usage = "\\\n'
              + output.strip() 
              + '";', file=fsock)

    if outfile:
        fsock.close()

if __name__ == "__main__":
    main()
