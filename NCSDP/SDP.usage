(*************************************************************************
 *         This file was automatically generated by md2usage.py          *
 *                   on 2022-02-09 09:27:54.090769                       *
 *************************************************************************)


(* SDPMatrices *)
SDPMatrices::usage = "\
SDPMatrices[f, G, y] converts the symbolic linear functions f, G in the variables y associated to the semidefinite program:

$$
\\begin{aligned} 
  \\min_y \\quad & f(y), \\\\
  \\text{s.t.} \\quad & G(y) \\succeq 0
\\end{aligned}
$$

into numerical data that can be used to solve an SDP in the form:

$$
\\begin{aligned}
  \\max_{y, S} \\quad & b^T y \\\\
  \\text{s.t.} \\quad & A y + S = c \\\\
                    & S \\succeq 0
\\end{aligned}
$$

SDPMatrices returns a list with three entries:

-   The first is the coefficient array A;
-   The second is the coefficient array b;
-   The third is the coefficient array c.

For example:

    f = -x
    G = {{1, x}, {x, 1}}
    vars = {x}
    {A,b,c} = SDPMatrices[f, G, vars]

results in

    A = {{{{0, -1}, {-1, 0}}}}
    b = {{{1}}}
    c = {{{1, 0}, {0, 1}}}

All data is stored as SparseArrays.

See also: SDPSolve.";

(* SDPSolve *)
SDPSolve::usage = "\
SDPSolve[{A,b,c}] solves an SDP in the form:

$$
\\begin{aligned}
  \\max_{y, S} \\quad & b^T y \\\\
  \\text{s.t.} \\quad & A y + S = c \\\\
                    & S \\succeq 0
\\end{aligned}
$$

SDPSolve returns a list with four entries:

-   The first is the primal solution y;
-   The second is the dual solution X;
-   The third is the primal slack variable S;
-   The fourth is a list of flags:
    -   PrimalFeasible: True if primal problem is feasible;
    -   FeasibilityRadius: less than one if primal problem is feasible;
    -   PrimalFeasibilityMargin: close to zero if primal problem is feasible;
    -   DualFeasible: True if dual problem is feasible;
    -   DualFeasibilityRadius: close to zero if dual problem is feasible.

For example:

    {Y, X, S, flags} = SDPSolve[abc]

solves the SDP abc.

SDPSolve[{A,b,c}, options] uses options.

options are those of PrimalDual.

See also: SDPMatrices.";

(* SDPEval *)
SDPEval::usage = "\
SDPEval[A, y] evaluates the linear function Ay in an SDP.

This is a convenient replacement for SDPPrimalEval in which the list y can be used directly.

See also: SDPPrimalEval, SDPDualEval, SDPSolve, SDPMatrices.";

(* SDPPrimalEval *)
SDPPrimalEval::usage = "\
SDPPrimalEval[A, {{y}}] evaluates the linear function Ay in an SDP.

See SDPEval for a convenient replacement for SDPPrimalEval in which the list y can be used directly.

See also: SDPEval, SDPDualEval, SDPSolve, SDPMatrices.";

(* SDPDualEval *)
SDPDualEval::usage = "\
SDPDualEval[A, X] evaluates the linear function A^(*)X in an SDP.

See also: SDPPrimalEval, SDPSolve, SDPMatrices.";

(* SDPSylvesterEval *)
SDPSylvesterEval::usage = "\
SDPSylvesterEval[a, W] returns a matrix representation of the Sylvester mapping A^(*)(WA(Δ_(y))W) when applied to the scaling W.

SDPSylvesterEval[a, Wl, Wr] returns a matrix representation of the Sylvester mapping A^(*)(W_(l)A(Δ_(y))W_(r)) when applied to the left- and right-scalings Wl and Wr.

See also: SDPPrimalEval, SDPDualEval.";
