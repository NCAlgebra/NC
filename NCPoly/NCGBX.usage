(*************************************************************************
 *         This file was automatically generated by md2usage.py          *
 *                   on 2023-03-07 11:59:50.014056                       *
 *************************************************************************)


(* SetMonomialOrder *)
SetMonomialOrder::usage = "\
SetMonomialOrder[var1, var2, ...] sets the current monomial order.

For example

    SetMonomialOrder[a,b,c]

sets the lex order a ≪ b ≪ c.

If one uses a list of variables rather than a single variable as one of the arguments, then multigraded lex order is used. For example

    SetMonomialOrder[{a,b,c}]

sets the graded lex order a < b < c.

Another example:

    SetMonomialOrder[{{a, b}, {c}}]

or

    SetMonomialOrder[{a, b}, c]

set the multigraded lex order a < b ≪ c.

Finally

    SetMonomialOrder[{a,b}, {c}, {d}]

or

    SetMonomialOrder[{a,b}, c, d]

is equivalent to the following two commands

    SetKnowns[a,b] 
    SetUnknowns[c,d]

There is also an older syntax which is still supported:

    SetMonomialOrder[{a, b, c}, n]

sets the order of monomials to be a < b < c and assigns them grading level n.

    SetMonomialOrder[{a, b, c}, 1]

is equivalent to SetMonomialOrder[{a, b, c}]. When using this older syntax the user is responsible for calling ClearMonomialOrder to make sure that the current order is empty before starting.

In Version 6, SetMonomialOrder uses NCMonomialOrder, and NCMonomialOrderQ.

See also: ClearMonomialOrder, GetMonomialOrder, PrintMonomialOrder, SetKnowns, SetUnknowns, NCMonomialOrder, NCMonomialOrderQ.";

(* SetKnowns *)
SetKnowns::usage = "\
SetKnowns[var1, var2, ...] records the variables var1, var2, … to be corresponding to known quantities.

SetUnknowns and Setknowns prescribe a monomial order with the knowns at the the bottom and the unknowns at the top.

For example

    SetKnowns[a,b] 
    SetUnknowns[c,d]

is equivalent to

    SetMonomialOrder[{a,b}, {c}, {d}]

which corresponds to the order a < b ≪ c ≪ d and

    SetKnowns[a,b] 
    SetUnknowns[{c,d}]

is equivalent to

    SetMonomialOrder[{a,b}, {c, d}]

which corresponds to the order a < b ≪ c < d.

Note that SetKnowns flattens grading so that

    SetKnowns[a,b] 

and

    SetKnowns[{a},{b}] 

result both in the order a < b.

Successive calls to SetUnknowns and SetKnowns overwrite the previous knowns and unknowns. For example

    SetKnowns[a,b] 
    SetUnknowns[c,d]
    SetKnowns[c,d]
    SetUnknowns[a,b]

results in an ordering c < d ≪ a ≪ b.

See also: SetUnknowns, SetMonomialOrder.";

(* SetUnknowns *)
SetUnknowns::usage = "\
SetUnknowns[var1, var2, ...] records the variables var1, var2, … to be corresponding to unknown quantities.

SetUnknowns and SetKnowns prescribe a monomial order with the knowns at the the bottom and the unknowns at the top.

For example

    SetKnowns[a,b] 
    SetUnknowns[c,d]

is equivalent to

    SetMonomialOrder[{a,b}, {c}, {d}]

which corresponds to the order a < b ≪ c ≪ d and

    SetKnowns[a,b] 
    SetUnknowns[{c,d}]

is equivalent to

    SetMonomialOrder[{a,b}, {c, d}]

which corresponds to the order a < b ≪ c < d.

Note that SetKnowns flattens grading so that

    SetKnowns[a,b] 

and

    SetKnowns[{a},{b}] 

result both in the order a < b.

Successive calls to SetUnknowns and SetKnowns overwrite the previous knowns and unknowns. For example

    SetKnowns[a,b] 
    SetUnknowns[c,d]
    SetKnowns[c,d]
    SetUnknowns[a,b]

results in an ordering c < d ≪ a ≪ b.

See also: SetKnowns, SetMonomialOrder.";

(* ClearMonomialOrder *)
ClearMonomialOrder::usage = "\
ClearMonomialOrder[] clear the current monomial ordering.

It is only necessary to use ClearMonomialOrder if using the indexed version of SetMonomialOrder.

See also: SetKnowns, SetUnknowns, SetMonomialOrder, ClearMonomialOrder, PrintMonomialOrder.";

(* GetMonomialOrder *)
GetMonomialOrder::usage = "\
GetMonomialOrder[] returns the current monomial ordering in the form of a list.

For example

    SetMonomialOrder[{a,b}, {c}, {d}]
    order = GetMonomialOrder[]

returns

    order = {{a,b},{c},{d}}

See also: SetKnowns, SetUnknowns, SetMonomialOrder, ClearMonomialOrder, PrintMonomialOrder.";

(* PrintMonomialOrder *)
PrintMonomialOrder::usage = "\
PrintMonomialOrder[] prints the current monomial ordering.

For example

    SetMonomialOrder[{a,b}, {c}, {d}]
    PrintMonomialOrder[]

print a < b ≪ c ≪ d.

See also: SetKnowns, SetUnknowns, SetMonomialOrder, ClearMonomialOrder, PrintMonomialOrder.";

(* NCMakeGB *)
NCMakeGB::usage = "\
NCMakeGB[{poly1, poly2, ...}, k] attempts to produces a nc Gröbner Basis (GB) associated with the list of nc polynomials {poly1, poly2, ...}. The GB algorithm proceeds through at most k iterations until a Gröbner basis is found for the given list of polynomials with respect to the order imposed by SetMonomialOrder.

If NCMakeGB terminates before finding a GB the message NCMakeGB::Interrupted is issued.

The output of NCMakeGB is a list of rules with left side of the rule being the leading monomial of the polynomials in the GB.

For example:

    SetMonomialOrder[x];
    gb = NCMakeGB[{x^2 - 1, x^3 - 1}, 20]

returns

    gb = {x -> 1}

that corresponds to the polynomial x − 1, which is the nc Gröbner basis for the ideal generated by x² − 1 and x³ − 1.

NCMakeGB[{poly1, poly2, ...}, k, options] uses options.

For example

    gb = NCMakeGB[{x^2 - 1, x^3 - 1}, 20, RedudeBasis -> True]

runs the Gröbner basis algortihm and completely reduces the output set of polynomials.

The following options can be given:

-   ReduceBasis (True): control whether the resulting basis output by the command is a reduced Gröbner basis at the completion of the algorithm. This corresponds to running NCReduce with the Boolean flag True to completely reduce the output basis. Can be set globally as SetOptions[NCMakeGB, ReturnBasis -> True].
-   SimplifyObstructions (True): control whether whether to remove obstructions before constructing more S-polynomials;
-   SortObstructions (False): control whether obstructions are sorted before being processed;
-   SortBasis (False): control whether initial basis is sorted before initiating algorithm;
-   VerboseLevel (1): control level of verbosity from 0 (no messages) to 5 (very verbose);
-   PrintBasis (False): if True prints current basis at each major iteration;
-   PrintObstructions (False): if True prints current list of obstructions at each major iteration;
-   PrintSPolynomials (False): if True prints every S-polynomial formed at each minor iteration.
-   ReturnRules (True): if True rules representing relations in which the left-hand side is the leading monomial are returned instead of polynomials. Use False for backward compatibility. Can be set globally as SetOptions[NCMakeGB, ReturnRules -> False].

NCMakeGB makes use of the algorithm NCPolyGroebner implemented in NCPolyGroebner.

In Version 6, NCMakeGB uses NCRationalToNCPoly to add additional relations involving rational variables and rational terms.

See also: NCRationalToNCPoly, NCReduce, ClearMonomialOrder, GetMonomialOrder, PrintMonomialOrder, SetKnowns, SetUnknowns, NCPolyGroebner.";

(* NCProcess *)
NCProcess::usage = "\
NCProcess[{poly1, poly2, ...}, k] finds a new generating set for the ideal generated by {poly1, poly2, ...} using NCMakeGB then produces an summary report on the findings.

Not all features of NCProcess in the old NCGB C++ version are supported yet.

See also: NCMakeGB.";

(* NCGBSimplifyRational *)
NCGBSimplifyRational::usage = "\
NCGBSimplifyRational[expr] creates a set of relations for each rational expression and sub-expression found in expr which are used to produce simplification rules using NCMakeGB then replaced using NCReduce.

For example:

    expr = x ** inv[1 - x] - inv[1 - x] ** x
    NCGBSimplifyRational[expr]

or

    expr = inv[1 - x - y ** inv[1 - x] ** y] - 1/2 (inv[1 - x + y] + inv[1 - x - y])
    NCGBSimplifyRational[expr]

both result in 0.

See also: NCMakeGB, NCReduce.";
